#!/usr/bin/perl -wT
#
# ==========================================================================
#
# ZoneMinder Event Filter Script, $Date$, $Revision$
# Copyright (C) 2003  Philip Coombes
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# ==========================================================================
#
# This script continuously monitors the recorded events for the given
# monitor and applies any filters which would delete and/or upload 
# matching events
#
use strict;

# ==========================================================================
#
# These are the elements you need to edit to suit your installation
#
# ==========================================================================
use constant ZM_PATH_BIN => "<from zmconfig>";
use constant ZM_PATH_WEB => "<from zmconfig>";
use constant ZM_PATH_CGI => "<from zmconfig>";
use constant ZM_DB_SERVER => "<from zmconfig>";
use constant ZM_DB_NAME => "<from zmconfig>";
use constant ZM_DB_USERA => "<from zmconfig>";
use constant ZM_DB_PASSA => "<from zmconfig>";

# Load the config from the database into the symbol table
BEGIN
{
	use DBI;
	no strict 'refs';
	my $dbh = DBI->connect( "DBI:mysql:database=".ZM_DB_NAME.";host=".ZM_DB_SERVER, ZM_DB_USERA, ZM_DB_PASSA );

	my $sql = "select * from Config";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
	while( my $config = $sth->fetchrow_hashref() )
	{
		*{$config->{Name}} = sub { $config->{Value} };
	}
	$sth->finish();
	$dbh->disconnect();
}

use constant EVENT_PATH => ZM_PATH_WEB.'/'.ZM_DIR_EVENTS;
use constant LOG_FILE => ZM_PATH_LOGS.'/zmfilter.log';
use constant START_DELAY => 5; # How long to wait before starting
use constant CHECK_DELAY => 60; # How long between each event check
use constant VERBOSE => 0; # Whether to output more verbose debug

if ( ZM_OPT_UPLOAD )
{
	# Comment these out if you don't have them and don't want to upload
	# or don't want to use that format
	if ( ZM_UPLOAD_ARCH_FORMAT eq "zip" )
	{
		require Archive::Zip;
		import Archive::Zip qw( :ERROR_CODES :CONSTANTS );
	}
	else
	{
		require Archive::Tar;
	}
	use Net::FTP;
}

my $email_subject;
my $email_body;
if ( ZM_OPT_EMAIL )
{
	use MIME::Entity;

	( $email_subject, $email_body ) = ZM_EMAIL_TEXT =~ /subject\s*=\s*"([^\n]*)".*body\s*=\s*"(.*)"/ms;
}

my $message_subject;
my $message_body;
if ( ZM_OPT_MESSAGE )
{
	use MIME::Entity;

	( $message_subject, $message_body ) = ZM_MESSAGE_TEXT =~ /subject\s*=\s*"([^\n]*)".*body\s*=\s*"(.*)"/ms;
}

# ==========================================================================
#
# You shouldn't need to change anything from here downwards
#
# ==========================================================================

use DBI;
use POSIX;
use Date::Manip;
use Data::Dumper;
use Getopt::Long;

$| = 1;

$ENV{PATH}  = '/bin:/usr/bin';
$ENV{SHELL} = '/bin/sh' if exists $ENV{SHELL};
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

my $delay = CHECK_DELAY;
my $event_id = 0;

sub Usage
{
	print( "
Usage: zmfilter.pl [-e <event_id>,--event=<event_id>] [-d <seconds>,--delay=<seconds>]
Parameters are :-
-e<event_id>, --event=<event_id>        - What event to start scanning from
-d<seconds>, --delay=<seconds>          - How long to delay between each check, default 60
");
	exit( -1 );
}

#
# More or less replicates the equivalent PHP function
#
sub strtotime
{
	my $dt_str = shift;
	return( UnixDate( $dt_str, '%s' ) );
}

#
# More or less replicates the equivalent PHP function
#
sub str_repeat
{
	my $string = shift;
	my $count = shift;
	return( ${string}x${count} );
}

# Formats a date into MySQL format
sub DateTimeToSQL
{
	my $dt_str = shift;
	my $dt_val = strtotime( $dt_str );
	if ( !$dt_val )
	{
		print( STDERR "Error, unable to parse date string '$dt_str'" );
		return( undef );
	}
	return( strftime( "%Y-%m-%d %H:%M:%S", localtime( $dt_val ) ) );
}

if ( !GetOptions( 'event=i'=>\$event_id, 'delay=i'=>\$delay ) )
{
	Usage();
}

my $log_file = LOG_FILE;
open( LOG, ">>$log_file" ) or die( "Can't open log file: $!" );
open( STDOUT, ">&LOG" ) || die( "Can't dup stdout: $!" );
select( STDOUT ); $| = 1;
open( STDERR, ">&LOG" ) || die( "Can't dup stderr: $!" );
select( STDERR ); $| = 1;
select( LOG ); $| = 1;

chdir( EVENT_PATH );

my $dbh = DBI->connect( "DBI:mysql:database=".ZM_DB_NAME.";host=".ZM_DB_SERVER, ZM_DB_USERA, ZM_DB_PASSA );

my $last_event_id;

if ( !$event_id )
{
	my $sql = "select max(Id) as MaxEventId from Events";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
	my $row = $sth->fetchrow_hashref();
	$event_id = $row->{MaxEventId};
	$sth->finish();
}
print( "Scanning for events since id $event_id\n" );

sleep( START_DELAY );

my $filters = GetFilters();
my @id_filters;
my @date_filters;
my $last_action = 0;

while( 1 )
{
	if ( (time() - $last_action) > ZM_FILTER_RELOAD_DELAY )
	{
		print( "Reloading filters\n" ) if ( VERBOSE );
		$last_action = time();
		$filters = GetFilters();
		@id_filters = grep { !$_->{has_dates} } @$filters;
		@date_filters = grep { $_->{has_dates} } @$filters;
	}

	foreach my $filter ( @date_filters )
	{
		CheckFilter( $filter );
	}

	my $sql = "select max(Id) as LastEventId from Events";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
	my $row = $sth->fetchrow_hashref();
	$last_event_id = $row->{LastEventId};
	$sth->finish();

	if ( $last_event_id && $last_event_id > $event_id )
	{
		print( "Last event generated is $last_event_id\n" ) if ( VERBOSE );
		# Got new event to check
		foreach my $filter ( @id_filters )
		{
			CheckFilter( $filter );
		}
		$event_id = $last_event_id;
	}
	else
	{
		print( "Sleeping for $delay seconds\n" ) if ( VERBOSE );
		sleep( $delay );
	}
}

sub GetFilters
{
	my @filters;
	my $sql = "select * from Filters where (AutoArchive = 1 or AutoDelete = 1 or AutoUpload = 1 or AutoEmail = 1 or AutoMessage = 1) order by Name";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
	FILTER: while( my $filter_data = $sth->fetchrow_hashref() )
	{
		print( "Found filter '$filter_data->{Name}'\n" ) if ( VERBOSE );
		my %filter_terms;
		foreach my $filter_parm ( split( '&', $filter_data->{Query} ) )
		{
			my( $key, $value ) = split( '=', $filter_parm, 2 );
			if ( $key )
			{
				$filter_terms{$key} = $value;
			}
		}
		#print( Dumper( %filter_terms ) );
		my $sql = "select E.Id,E.MonitorId,M.Name as MonitorName,E.Name,E.StartTime,unix_timestamp(E.StartTime) as Time,E.Length,E.Frames,E.AlarmFrames,E.TotScore,E.AvgScore,E.MaxScore,E.Archived,E.Uploaded,E.Emailed,E.Messaged,E.LearnState from Events as E inner join Monitors as M on M.Id = E.MonitorId where not isnull(E.EndTime)";
		my $filter_sql = '';
		for ( my $i = 1; $i <= $filter_terms{trms}; $i++ )
		{
			my $conjunction_name = "cnj$i";
			my $obracket_name = "obr$i";
			my $cbracket_name = "cbr$i";
			my $attr_name = "attr$i";
			my $op_name = "op$i";
			my $value_name = "val$i";
			if ( $filter_terms{$conjunction_name} )
			{
				$filter_sql .= " ".$filter_terms{$conjunction_name}." ";
			}
			if ( $filter_terms{$obracket_name} )
			{
				$filter_sql .= str_repeat( "(", $filter_terms{$obracket_name} );
			}
			my $value = $filter_terms{$value_name};
			my @value_list;
			if ( $filter_terms{$attr_name} )
			{
				if ( $filter_terms{$attr_name} =~ '/^Monitor/' )
				{
					my ( $temp_attr_name ) = $filter_terms{$attr_name} =~ /^Monitor(.+)$/;
					$filter_sql .= "M.".$temp_attr_name;
				}
				elsif ( $filter_terms{$attr_name} eq 'DateTime' )
				{
					$filter_sql .= "E.StartTime";
					# Indicate that this filter uses dates and so should not be dependant on the event id
					$filter_data->{has_dates} = !undef;
				}
				elsif ( $filter_terms{$attr_name} eq 'Date' )
				{
					$filter_sql .= "to_days( E.StartTime )";
					# Indicate that this filter uses dates and so should not be dependant on the event id
					$filter_data->{has_dates} = !undef;
				}
				elsif ( $filter_terms{$attr_name} eq 'Time' )
				{
					$filter_sql .= "extract( hour_second from E.StartTime )";
				}
				elsif ( $filter_terms{$attr_name} eq 'Weekday' )
				{
					$filter_sql .= "weekday( E.StartTime )";
				}
				elsif ( $filter_terms{$attr_name} eq 'Archived' )
				{
					$filter_sql .= "E.Archived = ".$filter_terms{$value_name};
				}
				else
				{
					$filter_sql .= "E.".$filter_terms{$attr_name};
				}

				( my $stripped_value = $value ) =~ s/^["\']+?(.+)["\']+?$/$1/;
				foreach my $temp_value ( split( '/["\'\s]*?,["\'\s]*?/', $stripped_value ) )
				{
					if ( $filter_terms{$attr_name} =~ '/^Monitor/' )
					{
						$value = "'$temp_value'";
					}
					elsif ( $filter_terms{$attr_name} eq 'DateTime' )
					{
						$value = DateTimeToSQL( $temp_value );
						if ( !$value )
						{
							print( STDERR "Error parsing date/time '$value', skipping filter '$filter_data->{Name}'\n" );
							next FILTER;
						}
						$value = "'$value'";
					}
					elsif ( $filter_terms{$attr_name} eq 'Date' )
					{
						$value = DateTimeToSQL( $temp_value );
						if ( !$value )
						{
							print( STDERR "Error parsing date/time '$value', skipping filter '$filter_data->{Name}'\n" );
							next FILTER;
						}
						$value = "to_days( '$value' )";
					}
					elsif ( $filter_terms{$attr_name} eq 'Time' )
					{
						$value = DateTimeToSQL( $temp_value );
						if ( !$value )
						{
							print( STDERR "Error parsing date/time '$value', skipping filter '$filter_data->{Name}'\n" );
							next FILTER;
						}
						$value = "extract( hour_second from '$value' )";
					}
					elsif ( $filter_terms{$attr_name} eq 'Weekday' )
					{
						$value = DateTimeToSQL( $temp_value );
						if ( !$value )
						{
							print( STDERR "Error parsing date/time '$value', skipping filter '$filter_data->{Name}'\n" );
							next FILTER;
						}
						$value = "weekday( '$value' )";
					}
					else
					{
						$value = $temp_value;
					}
					push( @value_list, $value );
				}
			}
			if ( $filter_terms{$op_name} )
			{
				if ( $filter_terms{$op_name} eq '=~' )
				{
					$filter_sql .= " regexp $value";
				}
				elsif ( $filter_terms{$op_name} eq '!~' )
				{
					$filter_sql .= " not regexp $value";
				}
				elsif ( $filter_terms{$op_name} eq '=[]' )
				{
					$filter_sql .= " in (".join( ",", @value_list ).")";
				}
				elsif ( $filter_terms{$op_name} eq '!~' )
				{
					$filter_sql .= " not in (".join( ",", @value_list ).")";
				}
				else
				{
					$filter_sql .= " ".$filter_terms{$op_name}." $value";
				}
			}
			if ( $filter_terms{$cbracket_name} )
			{
				$filter_sql .= str_repeat( ")", $filter_terms{$cbracket_name} );
			}
		}
		if ( $filter_sql )
		{
			$sql .= " and ( $filter_sql )";
		}
		if ( !$filter_data->{has_dates} )
		{
			$sql .= " and E.Id > ?";
		}
		$sql .= " order by E.Id";
		#print $sql."\n";
		$filter_data->{Sql} = $sql;
		push( @filters, $filter_data );
	}
	$sth->finish();

	return( \@filters );
}

sub CheckFilter
{
	my $filter = shift;

	print( "Checking filter '$filter->{Name}'".
		($filter->{AutoArchive}?", archive":"").
		($filter->{AutoDelete}?", delete":"").
		($filter->{AutoUpload}?", upload":"").
		($filter->{AutoEmail}?", email":"").
		($filter->{AutoMessage}?", message":"").
		"\n"
	) if ( VERBOSE );
	my $sql = $filter->{Sql};
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res;
	if ( $filter->{has_dates} )
	{
		$res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
	}
	else
	{
		$res = $sth->execute( $event_id ) or die( "Can't execute: ".$sth->errstr() );
	}

	while( my $event = $sth->fetchrow_hashref() )
	{
		print( "Checking event $event->{Id}\n" ) if ( VERBOSE );
		if ( ZM_OPT_EMAIL && $filter->{AutoEmail} )
		{
			next if ( $event->{Emailed} );

			sendEmail( $filter, $event );
		}
		if ( ZM_OPT_MESSAGE && $filter->{AutoMessage} )
		{
			next if ( $event->{Messaged} );

			sendMessage( $filter, $event );
		}
		if ( ZM_OPT_UPLOAD && $filter->{AutoUpload} )
		{
			next if ( $event->{Uploaded} );

			uploadArchFile( $filter, $event );
		}
		if ( $filter->{AutoArchive} )
		{
			print( "Archiving event $event->{Id}\n" );
			# Do it individually to avoid locking up the table for new events
			my $sql = "update Events set Archived = 1 where Id = ?";
			my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
			my $res = $sth->execute( $event->{Id} ) or die( "Can't execute: ".$sth->errstr() );
		}
		if ( $filter->{AutoDelete} )
		{
			print( "Deleting event $event->{Id}\n" );
			# Do it individually to avoid locking up the table for new events
			my $sql = "delete from Events where Id = ?";
			my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
			my $res = $sth->execute( $event->{Id} ) or die( "Can't execute: ".$sth->errstr() );

			# We could now delete from the Frames and Stats table and the files themselves,
			# but we can let the database checker sort that out for us instead
		}
	}
	$sth->finish();
}

sub uploadArchFile
{
	my $filter = shift;
	my $event = shift;

	my $arch_file = ZM_UPLOAD_FTP_LOC_DIR.'/'.$event->{MonitorName}.'-'.$event->{Id};
	my $arch_image_path = "$event->{MonitorName}/$event->{Id}/".((ZM_UPLOAD_ARCH_ANALYSE)?'{analyse,capture}':'*capture').".jpg";
	my $arch_error;

	if ( ZM_UPLOAD_ARCH_FORMAT eq "zip" )
	{
		$arch_file .= '.zip';
		my $zip = Archive::Zip->new();
		print( "Creating upload file '$arch_file'\n" );

		my $status = &AZ_OK;
		foreach my $image_file ( <*$arch_image_path> )
		{
			print( "Adding $image_file\n" );
			my $member = $zip->addFile( $image_file );
			last unless ( $member );
			$member->desiredCompressionMethod( (ZM_UPLOAD_ARCH_COMPRESS)?&COMPRESSION_DEFLATED:&COMPRESSION_STORED );
		}
		$status = $zip->writeToFileNamed( $arch_file );

		if ( $arch_error = ($status != &AZ_OK) )
		{
			print( "Zip error: $status\n " );
		}
	}
	elsif ( ZM_UPLOAD_ARCH_FORMAT eq "tar" )
	{
		if ( ZM_UPLOAD_ARCH_COMPRESS )
		{
			$arch_file .= '.tar.gz';
		}
		else
		{
			$arch_file .= '.tar';
		}
		print( "Creating upload file '$arch_file'\n" );

		if ( $arch_error = !Archive::Tar->create_archive( $arch_file, ZM_UPLOAD_ARCH_COMPRESS, <*$arch_image_path> ) )
		{
			print( "Tar error: ".Archive::Tar->error()."\n " );
		}
	}


	if ( !$arch_error )
	{
		print( "Uploading to ".ZM_UPLOAD_FTP_HOST."\n" );
		my $ftp = Net::FTP->new( ZM_UPLOAD_FTP_HOST, Timeout=>ZM_UPLOAD_FTP_TIMEOUT, Passive=>ZM_UPLOAD_FTP_PASSIVE, Debug=>ZM_UPLOAD_FTP_DEBUG );
		if ( !$ftp )
		{
			warn( "Can't create ftp connection: $@" );
			return();
		}

		$ftp->login( ZM_UPLOAD_FTP_USER, ZM_UPLOAD_FTP_PASS ) or warn( "FTP - Can't login" );
		$ftp->binary() or warn( "FTP - Can't go binary" );
		$ftp->cwd( ZM_UPLOAD_FTP_REM_DIR ) or warn( "FTP - Can't cwd" );
		$ftp->put( $arch_file ) or warn( "FTP - Can't upload '$arch_file'" );
		$ftp->quit() or warn( "FTP - Can't quit" );
		unlink( $arch_file );
		my $sql = "update Events set Uploaded = 1 where Id = ?";
		my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
		my $res = $sth->execute( $event->{Id} ) or die( "Can't execute: ".$sth->errstr() );
	}
}

sub sendEmail
{
	my $filter = shift;
	my $event = shift;

	if ( !ZM_FROM_EMAIL )
	{
		warn( "No 'from' email address defined, not sending email" );
		return;
	}
	if ( !ZM_EMAIL_ADDRESS )
	{
		warn( "No email address defined, not sending email" );
		return;
	}

	print( "Creating notification email\n" );

	my $subject = substituteTags( $email_subject, $filter, $event );
	my @attachments;
	my $body = substituteTags( $email_body, $filter, $event, \@attachments );

	print( "Sending notification email '$subject'\n" );
	print( "$body\n" ) if ( VERBOSE );

	eval
	{
		my $mail = MIME::Entity->build(
			From =>ZM_FROM_EMAIL,
			To=>ZM_EMAIL_ADDRESS,
			Subject=>$subject,
			Data=>$body
		);

		foreach my $attachment ( @attachments )
		{
			print( "Attaching '$attachment->{path}\n" );
			$mail->attach(
				Path=>$attachment->{path},
				Type=>$attachment->{type},
				Encoding=>"base64"
			);
		}

		$mail->smtpsend();
	};
	if ( $@ )
	{
		warn( "Can't send email: $@" );
		return();
	}
	my $sql = "update Events set Emailed = 1 where Id = ?";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute( $event->{Id} ) or die( "Can't execute: ".$sth->errstr() );
}

sub sendMessage
{
	my $filter = shift;
	my $event = shift;

	if ( !ZM_FROM_EMAIL )
	{
		warn( "No 'from' email address defined, not sending message" );
		return;
	}
	if ( !ZM_MESSAGE_ADDRESS )
	{
		warn( "No message address defined, not sending message" );
		return;
	}

	print( "Creating notification message\n" );

	my $subject = substituteTags( $message_subject, $filter, $event );
	my @attachments;
	my $body = substituteTags( $message_body, $filter, $event, \@attachments );

	print( "Sending notification message '$subject'\n" );
	print( "$body\n" ) if ( VERBOSE );

	eval
	{
		my $mail = MIME::Entity->build(
			From =>ZM_FROM_EMAIL,
			To=>ZM_MESSAGE_ADDRESS,
			Subject=>$subject,
			Data=>$body
		);

		foreach my $attachment ( @attachments )
		{
			print( "Attaching '$attachment->{path}\n" );
			$mail->attach(
				Path=>$attachment->{path},
				Type=>$attachment->{type},
				Encoding=>"base64"
			);
		}

		$mail->smtpsend();
	};
	if ( $@ )
	{
		warn( "Can't send email: $@" );
		return();
	}
	my $sql = "update Events set Messaged = 1 where Id = ?";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute( $event->{Id} ) or die( "Can't execute: ".$sth->errstr() );
}

sub substituteTags
{
	my $text = shift;
	my $filter = shift;
	my $event = shift;
	my $attachments_ref = shift;

	# First we'd better check what we need to get
	# We have a filter and an event, do we need any more
	# monitor information?
	my $need_monitor = $text =~ /%(?:MET|MEH|MED|MEW|MEN|MEA)%/;

	my $monitor = {};
	if ( $need_monitor )
	{
		my $db_now = strftime( "%Y-%m-%d %H:%M:%S", localtime() );
		my $sql = "select M.*, count(E.Id) as EventCount, count(if(E.Archived,1,NULL)) as ArchEventCount, count(if(E.StartTime>'$db_now' - INTERVAL 1 HOUR && E.Archived = 0,1,NULL)) as HourEventCount, count(if(E.StartTime>'$db_now' - INTERVAL 1 DAY && E.Archived = 0,1,NULL)) as DayEventCount, count(if(E.StartTime>'$db_now' - INTERVAL 7 DAY && E.Archived = 0,1,NULL)) as WeekEventCount, count(if(E.StartTime>'$db_now' - INTERVAL 1 MONTH && E.Archived = 0,1,NULL)) as MonthEventCount from Monitors as M left join Events as E on E.MonitorId = M.Id where MonitorId = ? group by E.MonitorId order by Id";
		my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
		my $res = $sth->execute( $event->{MonitorId} ) or die( "Can't execute: ".$sth->errstr() );
		$monitor = $sth->fetchrow_hashref();
		$sth->finish();
		return() if ( !$monitor );
	}

	# Do we need the image information too?
	my $need_images = $text =~ /%(?:EPI1|EPIM|EI1|EIM)%/;
	my $first_alarm_frame;
	my $max_alarm_frame;
	my $max_alarm_score = 0;
	if ( $need_images )
	{
		my $sql = "select * from Frames where EventId = ? and Type = 'Alarm' order by FrameId";
		my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
		my $res = $sth->execute( $event->{Id} ) or die( "Can't execute: ".$sth->errstr() );
		while( my $frame = $sth->fetchrow_hashref() )
		{
			if ( !$first_alarm_frame )
			{
				$first_alarm_frame = $frame;
			}
			if ( $frame->{Score} > $max_alarm_score )
			{
				$max_alarm_frame = $frame;
				$max_alarm_score = $frame->{Score};
			}
		}
		$sth->finish();
	}

	my $url = ZM_URL;
	$text =~ s/%ZP%/$url/g;
	$text =~ s/%MN%/$event->{MonitorName}/g;
	$text =~ s/%MET%/$monitor->{EventCount}/g;
	$text =~ s/%MEH%/$monitor->{HourEventCount}/g;
	$text =~ s/%MED%/$monitor->{DayEventCount}/g;
	$text =~ s/%MEW%/$monitor->{WeekEventCount}/g;
	$text =~ s/%MEM%/$monitor->{MonthEventCount}/g;
	$text =~ s/%MEA%/$monitor->{ArchEventCount}/g;
	$text =~ s/%MP%/$url?view=watch&mid=$event->{MonitorId}/g;
	$text =~ s/%MPS%/$url?view=watchfeed&mid=$event->{MonitorId}&mode=stream/g;
	$text =~ s/%MPI%/$url?view=watchfeed&mid=$event->{MonitorId}&mode=still/g;
	$text =~ s/%EP%/$url?view=event&mid=$event->{MonitorId}&eid=$event->{Id}/g;
	$text =~ s/%EPS%/$url?view=event&mode=stream&mid=$event->{MonitorId}&eid=$event->{Id}/g;
	$text =~ s/%EPI%/$url?view=event&mode=still&mid=$event->{MonitorId}&eid=$event->{Id}/g;
	$text =~ s/%EI%/$event->{Id}/g;
	$text =~ s/%EN%/$event->{Name}/g;
	$text =~ s/%ET%/$event->{StartTime}/g;
	$text =~ s/%ED%/$event->{Length}/g;
	$text =~ s/%EF%/$event->{Frames}/g;
	$text =~ s/%EFA%/$event->{AlarmFrames}/g;
	$text =~ s/%EST%/$event->{TotScore}/g;
	$text =~ s/%ESA%/$event->{AvgScore}/g;
	$text =~ s/%ESM%/$event->{MaxScore}/g;
	if ( $first_alarm_frame )
	{
		$text =~ s/%EPI1%/$url?view=image&mid=$event->{MonitorId}&eid=$event->{Id}&fid=$first_alarm_frame->{FrameId}/g;
		$text =~ s/%EPIM%/$url?view=image&mid=$event->{MonitorId}&eid=$event->{Id}&fid=$max_alarm_frame->{FrameId}/g;
		if ( $attachments_ref && $text =~ s/%EI1%//g )
		{
			push( @$attachments_ref, { type=>"image/jpeg", path=>sprintf( "%s/%d/%0".ZM_EVENT_IMAGE_DIGITS."d-capture.jpg", $event->{MonitorName}, $event->{Id}, $first_alarm_frame->{FrameId} ) } );
		}
		if ( $attachments_ref && $text =~ s/%EIM%//g )
		{
			# Don't attach the same image twice
			if ( !@$attachments_ref || ($first_alarm_frame->{FrameId} != $max_alarm_frame->{FrameId} ) )
			{
				push( @$attachments_ref, { type=>"image/jpeg", path=>sprintf( "%s/%d/%0".ZM_EVENT_IMAGE_DIGITS."d-capture.jpg", $event->{MonitorName}, $event->{Id}, $max_alarm_frame->{FrameId} ) } );
			}
		}
	}
	if ( $attachments_ref && ZM_OPT_MPEG ne "no" && $text =~ s/%EV%//g )
	{
		my $command = ZM_PATH_BIN."/zmvideo.pl -e $event->{Id}";
		my $output = qx($command);
		my $status = $? >> 8;
		if ( $status == 0 )
		{
			chomp $output;
			push( @$attachments_ref, { type=>"video/mpeg", path=>sprintf( "%s/%d/%s", $event->{MonitorName}, $event->{Id}, $output ) } );
		}
	}
	$text =~ s/%FN%/$filter->{Name}/g;
	( my $filter_name = $filter->{Name} ) =~ s/ /+/g;
	$text =~ s/%FP%/$url?view=filter&mid=$event->{MonitorId}&filter_name=$filter_name/g;
	
	return( $text );
}
