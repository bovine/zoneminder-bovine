#!/usr/bin/perl -wT
#
# ==========================================================================
#
# ZoneMinder Package Control Script, $Date$, $Revision$
# Copyright (C) 2003  Philip Coombes
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# ==========================================================================
#
# This script is used to start and stop the ZoneMinder package primarily to
# allow command line control for automatic restart on reboot (see zm script)
#
use strict;

# ==========================================================================
#
# These are the elements you need to edit to suit your installation
#
# ==========================================================================
use constant ZM_PATH_BIN => "<from zmconfig>";
use constant ZM_PATH_WEB => "<from zmconfig>";
use constant ZM_PATH_CGI => "<from zmconfig>";
use constant ZM_WEB_USER => "<from zmconfig>";
use constant ZM_WEB_GROUP => "<from zmconfig>";
use constant ZM_DB_SERVER => "<from zmconfig>";
use constant ZM_DB_NAME => "<from zmconfig>";
use constant ZM_DB_USERA => "<from zmconfig>";
use constant ZM_DB_PASSA => "<from zmconfig>";

# Load the config from the database into the symbol table
BEGIN
{
	use DBI;
	no strict 'refs';
	my $dbh = DBI->connect( "DBI:mysql:database=".ZM_DB_NAME.";host=".ZM_DB_SERVER, ZM_DB_USERA, ZM_DB_PASSA );

	my $sql = "select * from Config";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
	while( my $config = $sth->fetchrow_hashref() )
	{
		*{$config->{Name}} = sub { $config->{Value} };
	}
	$sth->finish();
	$dbh->disconnect();
}

use constant LOG_FILE => ZM_PATH_LOGS.'/zmpkg.log';
use constant VERBOSE => 0; # Whether to output more verbose debug

# ==========================================================================
#
# Don't change anything below here
#
# ==========================================================================
use DBI;

# Detaint our environment
$ENV{PATH}  = '/bin:/usr/bin';
$ENV{SHELL} = '/bin/sh' if exists $ENV{SHELL};
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

my $command = $ARGV[0];

my $state;

my $dbh = DBI->connect( "DBI:mysql:database=".ZM_DB_NAME.";host=".ZM_DB_SERVER, ZM_DB_USERA, ZM_DB_PASSA );

if ( !$command || $command !~ /^(?:start|stop|restart|status)$/ )
{
	if ( $command )
	{
		# Check to see if it's a valid run state
		my $sql = "select * from States where Name = '$command'";
		my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
		my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
		if ( $state = $sth->fetchrow_hashref() )
		{
			$state->{Name} = $command;
			$state->{Definitions} = [];
			foreach( split( ',', $state->{Definition} ) )
			{
				my ( $id, $function ) = split( ':', $_ );
				push( @{$state->{Definitions}}, { Id=>$id, Function=>$function } );
			}
			$command = 'state';
		}
		else
		{
			$command = undef;
		}
	}
	if ( !$command )
	{
		print( "Usage: zmpkg.pl <start|stop|restart|status|'state'>\n" );
		exit( -1 );
	}
}

sub remove_shm
{
	print( STDERR "Removing shared memory\n" );
	# Find ZoneMinder shared memory
	my $command = "ipcs -m | grep '^".substr( sprintf( "0x%x", hex(ZM_SHM_KEY) ), 0, -2 )."'";
	print( "Checking for shared memory with '$command'\n" ) if ( VERBOSE );
	open( CMD, "$command |" ) or die( "Can't execute '$command': $!" );
	while( <CMD> )
	{
		chomp;
		my ( $key, $id ) = split( /\s+/ );
		if ( $id =~ /^(\d+)/ )
		{
			$id = $1;
			my $command = "ipcrm shm $id";
			print( "Removing shared memory with '$command'\n" ) if ( VERBOSE );
			qx( $command );
		}
	}
	close( CMD );
}

sub execute
{
	my $command = shift;
	my ( $name ) = getpwuid( $> );
	if ( $name ne ZM_WEB_USER )
	{
		$command = "su ".ZM_WEB_USER." --shell=/bin/sh --command='$command'";
	}
	print( STDERR "Executing: $command\n" );
	return( qx( $command ) );
}

# Move to the right place
chdir( ZM_PATH_WEB ) or die( "Can't chdir to '".ZM_PATH_WEB."': $!" );

my $log_file = LOG_FILE;
open( LOG, ">>$log_file" ) or die( "Can't open log file: $!" );
#open( STDOUT, ">&LOG" ) || die( "Can't dup stdout: $!" );
#select( STDOUT ); $| = 1;
open( STDERR, ">&LOG" ) || die( "Can't dup stderr: $!" );
select( STDERR ); $| = 1;
select( LOG ); $| = 1;

print( STDERR "Command: $command\n" );

my $web_uid = (getpwnam( ZM_WEB_USER ))[2];
my $web_gid = (getgrnam( ZM_WEB_GROUP ))[2];
if ( $> != $web_uid )
{
	chown( $web_uid, $web_gid, $log_file ) or die( "Can't change permissions on log file: $!" )
}

my $retval = 0;

if ( $command eq "state" )
{
	print( STDERR "Updating DB: $state->{Name}\n" );
	my $sql = "select * from Monitors order by Id asc";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
	while( my $monitor = $sth->fetchrow_hashref() )
	{
		foreach my $definition ( @{$state->{Definitions}} )
		{
			if ( $monitor->{Id} =~ /^$definition->{Id}$/ )
			{
				$monitor->{NewFunction} = $definition->{Function};
			}
		}
		#next if ( !$monitor->{NewFunction} );
		$monitor->{NewFunction} = 'None' if ( !$monitor->{NewFunction} );
		if ( $monitor->{Function} ne $monitor->{NewFunction} )
		{
			my $sql = "update Monitors set Function = ? where Id = ?";
			my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
			my $res = $sth->execute( $monitor->{NewFunction}, $monitor->{Id} ) or die( "Can't execute: ".$sth->errstr() );
		}
	}
	$sth->finish();

	$command = "restart";
}

if ( $command =~ /^(?:stop|restart)$/ )
{
	my $status = execute( ZM_PATH_BIN."/zmdc.pl check" );
	chomp( $status );

	if ( $status eq "running" )
	{
		execute( ZM_PATH_BIN."/zmdc.pl shutdown" );
		remove_shm();
	}
	else
	{
		$retval = 1;
	}
}

if ( $command =~ /^(?:start|restart)$/ )
{
	my $status = execute( ZM_PATH_BIN."/zmdc.pl check" );
	chomp( $status );

	if ( $status eq "stopped" )
	{
		remove_shm();
		execute( ZM_PATH_BIN."/zmfix" );
		execute( ZM_PATH_BIN."/zmdc.pl status" );

		my $sql = "select * from Monitors";
		my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
		my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
		while( my $monitor = $sth->fetchrow_hashref() )
		{
			if ( $monitor->{Function} ne 'None' )
			{
				if ( $monitor->{Type} eq 'Local' )
				{
					execute( ZM_PATH_BIN."/zmdc.pl start zmc -d $monitor->{Device}" );
				}
				else
				{
					execute( ZM_PATH_BIN."/zmdc.pl start zmc -m $monitor->{Id}" );
				}
				if ( ( $monitor->{Function} eq 'Modect' )
				|| ( $monitor->{Function} eq 'Record' )
				|| ( $monitor->{Function} eq 'Mocord' ) )
				{
					if ( ZM_OPT_FRAME_SERVER )
					{
						execute( ZM_PATH_BIN."/zmdc.pl start zmf -m $monitor->{Id}" );
					}
					execute( ZM_PATH_BIN."/zmdc.pl start zma -m $monitor->{Id}" );
				}
				execute( ZM_PATH_BIN."/zmdc.pl start zmfilter.pl -m $monitor->{Id} -e -1" );
			}
		}
		$sth->finish();

		# This is now started unconditionally
		execute( ZM_PATH_BIN."/zmdc.pl start zmaudit.pl -d 900 -y" );

		if ( ZM_OPT_X10 )
		{
			execute( ZM_PATH_BIN."/zmdc.pl start zmx10.pl -c start" );
		}
		execute( ZM_PATH_BIN."/zmdc.pl start zmwatch.pl" );
		if ( ZM_CHECK_FOR_UPDATES )
		{
			execute( ZM_PATH_BIN."/zmdc.pl start zmupdate.pl -c" );
		}
	}
	else
	{
		$retval = 1;
	}
}

if ( $command eq "status" )
{
	my $status = execute( ZM_PATH_BIN."/zmdc.pl check" );
	chomp( $status );

	print( STDOUT $status."\n" );
}

exit( $retval );
