#!/usr/bin/perl -w
#
# ==========================================================================
#
# ZoneMinder WatchDog Script, $Date$, $Revision$
# Copyright (C) 2003  Philip Coombes
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# ==========================================================================
#
# This script just checks what the most recent release of ZoneMinder is
# at the the moment. It will eventually be responsible for applying and
# configuring upgrades etc, including on the fly upgrades.
#

# ==========================================================================
#
# These are the elements you need to edit to suit your installation
#
# ==========================================================================

use constant ZM_VERSION => "<from zmconfig>";
use constant ZM_PATH_BIN => "<from zmconfig>";
use constant ZM_PATH_WEB => "<from zmconfig>";
use constant ZM_DB_SERVER => "<from zmconfig>";
use constant ZM_DB_NAME => "<from zmconfig>";
use constant ZM_DB_USERA => "<from zmconfig>";
use constant ZM_DB_PASSA => "<from zmconfig>";

# Load the config from the database into the symbol table
BEGIN
{
	use DBI;
	no strict 'refs';
	my $dbh = DBI->connect( "DBI:mysql:database=".ZM_DB_NAME.";host=".ZM_DB_SERVER, ZM_DB_USERA, ZM_DB_PASSA );

	my $sql = "select * from Config";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
	while( my $config = $sth->fetchrow_hashref() )
	{
		*{$config->{Name}} = sub { $config->{Value} };
	}
	$sth->finish();
	$dbh->disconnect();
}

use constant UPDATE_LOG_FILE => ZM_PATH_LOGS.'/zmupdate.log';
use constant CHECK_INTERVAL => (1*24*60*60); # Interval between version checks
use constant EVENT_PATH => ZM_PATH_WEB.'/'.ZM_DIR_EVENTS;
use constant VERBOSE => 0; # Whether to output more verbose debug

# ==========================================================================
#
# Don't change anything below here
#
# ==========================================================================

use strict;
use POSIX;
use DBI;
use Getopt::Long;
use Data::Dumper;

$| = 1;

$ENV{PATH}  = '/bin:/usr/bin';
$ENV{SHELL} = '/bin/sh' if exists $ENV{SHELL};
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

my $check = undef;
my $rename = undef;
my $zone_fix = undef;
sub Usage
{
    print( "
Usage: zmupdate.pl -e <event_id>,--event=<event_id> [-r <rate>,--rate=<rate>] [-s <scale>,--scale=<scale>] [-o,--overwrite]
Parameters are :-
-c, --check         - Check for updated versions of ZoneMinder
-r, --rename        - Rename images from old 'capture-nnn.jpg' format to new 'nnn-capture.jpg' style from v1.17.2
-z, --zone-fix      - Update zone percentage sizes from %ge of image to %ge of zone from 1.18.2 onwards
");
    exit( -1 );
}

if ( !GetOptions( 'check'=>\$check, 'rename'=>\$rename, 'zone-fix'=>\$zone_fix ) )
{
	Usage();
}

if ( ! ($check || $rename || $zone_fix) )
{
	print( STDERR "Please give a valid option\n" );
	Usage();
}

if ( ($check + $rename + $zone_fix) > 1 )
{
	print( STDERR "Please give only one option\n" );
	Usage();
}

open( LOG, '>>'.UPDATE_LOG_FILE ) or die( "Can't open log file: $!" );
open( STDOUT, ">&LOG" ) || die( "Can't dup stdout: $!" );
select( STDOUT ); $| = 1;
open( STDERR, ">&LOG" ) || die( "Can't dup stderr: $!" );
select( STDERR ); $| = 1;
select( LOG ); $| = 1;
print( "Update agent starting at ".strftime( '%y/%m/%d %H:%M:%S', localtime() )."\n" );

my $dbh = DBI->connect( "DBI:mysql:database=".ZM_DB_NAME.";host=".ZM_DB_SERVER, ZM_DB_USERA, ZM_DB_PASSA );

if ( $check && ZM_CHECK_FOR_UPDATES )
{
	my $last_version = ZM_DYN_LAST_VERSION;
	my $curr_version = ZM_DYN_CURR_VERSION;
	my $last_check = ZM_DYN_LAST_CHECK;

	if ( !$curr_version )
	{
		$curr_version = ZM_VERSION;

		my $sql = "update Config set Value = ? where Name = 'ZM_DYN_CURR_VERSION'";
		my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
		my $res = $sth->execute( $curr_version ) or die( "Can't execute: ".$sth->errstr() );
	}

	while( 1 )
	{
		my $now = time();
		if ( !$last_version || !$last_check || (($now-$last_check) > CHECK_INTERVAL) )
		{
			print( "Checking for updates at ".strftime( '%y/%m/%d %H:%M:%S', localtime() )."\n" );

			use LWP::UserAgent;
			my $ua = LWP::UserAgent->new;
			$ua->agent( "ZoneMinder Update Agent/".ZM_VERSION );

			my $req = HTTP::Request->new( GET=>'http://www.zoneminder.com/version' );
			my $res = $ua->request($req);

			if ( $res->is_success )
			{
				$last_version = $res->content;
				chomp($last_version);
				$last_check = $now;

				print( "Got version: '".$last_version."'\n" );

				{
				my $sql = "update Config set Value = ? where Name = 'ZM_DYN_LAST_VERSION'";
				my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
				my $res = $sth->execute( $last_version ) or die( "Can't execute: ".$sth->errstr() );
				}
				{
				my $sql = "update Config set Value = ? where Name = 'ZM_DYN_LAST_CHECK'";
				my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
				my $res = $sth->execute( $last_check ) or die( "Can't execute: ".$sth->errstr() );
				}
			}
			else
			{
				print( "Error check failed: '".$res->status_line()."'\n" );
			}

		}
		sleep( 3600 );
	}
}
if ( $rename )
{
	require File::Find;

	chdir( EVENT_PATH );

	sub renameImage
	{
		my $file = $_;

		# Ignore directories
		if ( -d $file )
		{
			print( "Checking directory '$file'\n" );
			return;
		}
		if ( $file !~ /(capture|analyse)-(\d+)(\.jpg)/ )
		{
			return;
		}
		my $new_file = "$2-$1$3";

		print( "Renaming '$file' to '$new_file'\n" );
		rename( $file, $new_file ) or warn( "Can't rename '$file' to '$new_file'" );
	}

	File::Find::find( \&renameImage, '.' );
}
if ( $zone_fix )
{
	require DBI;

	my $dbh = DBI->connect( "DBI:mysql:database=".ZM_DB_NAME.";host=".ZM_DB_SERVER, ZM_DB_USERA, ZM_DB_PASSA );

	my $sql = "select Z.*, M.Width as MonitorWidth, M.Height as MonitorHeight from Zones as Z inner join Monitors as M on Z.MonitorId = M.Id where Z.Units = 'Percent'";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
	my @zones;
	while( my $zone = $sth->fetchrow_hashref() )
	{
		push( @zones, $zone );
	}
	$sth->finish();

	foreach my $zone ( @zones )
	{
		my $zone_width = (($zone->{HiX}*$zone->{MonitorWidth})-($zone->{LoX}*$zone->{MonitorWidth}));
		my $zone_height = (($zone->{HiY}*$zone->{MonitorHeight})-($zone->{LoY}*$zone->{MonitorHeight}));
		my $zone_area = $zone_width * $zone_height;
		my $monitor_area = $zone->{MonitorWidth} * $zone->{MonitorHeight};
		my $sql = "update Zones set MinAlarmPixels = ?, MaxAlarmPixels = ?, MinFilterPixels = ?, MaxFilterPixels = ?, MinBlobPixels = ?, MaxBlobPixels = ? where MonitorId = ? and Units = 'Percent'";
		my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
		my $res = $sth->execute(
			($zone->{MinAlarmPixels}*$monitor_area)/$zone_area,
			($zone->{MaxAlarmPixels}*$monitor_area)/$zone_area,
			($zone->{MinFilterPixels}*$monitor_area)/$zone_area,
			($zone->{MaxFilterPixels}*$monitor_area)/$zone_area,
			($zone->{MinBlobPixels}*$monitor_area)/$zone_area,
			($zone->{MaxBlobPixels}*$monitor_area)/$zone_area,
			$zone->{MonitorId}
		) or die( "Can't execute: ".$sth->errstr() );
	}
}
print( "Update agent exiting at ".strftime( '%y/%m/%d %H:%M:%S', localtime() )."\n" );
exit();
