#!/usr/bin/perl -w
#
# ==========================================================================
#
# Zone Minder Configuration Script, $Date$, $Revision$
# Copyright (C) 2003  Philip Coombes
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# ==========================================================================
#
# This script is used to provide an interactive initial configuration of
# ZoneMinder in one central place reducing the need to edit individual files.
#

use strict;
use Data::Dumper;
use Getopt::Long;
use DBI;

$| = 1;

sub Usage
{
	print( "
Usage: zmconfig.pl [-f <config file>,--file=<config file>] [-(no)i,--(no)interactive] [-(no)r,--(no)reprocess]
Parameters are :-
-f <config_file>, --file=<config_file> - Use a configuration file other and the default zmconfig.txt
-(no)i, --(no)interactive              - Whether to include interactive configuration, on by default 
-(no)r, --(no)reprocess                - Whether to reprocess files, on by default
");
	exit( -1 );
}

my $config_file = "zmconfig.txt";
my $config_header = "src/zm_config_defines.h";
my $interactive = !undef;
my $reprocess = !undef;

if ( !GetOptions( 'file=s'=>\$config_file, 'interactive!'=>\$interactive, 'reprocess!'=>\$reprocess ) )
{
	Usage();
}

my @match_options;
while( @ARGV )
{
	push( @match_options, shift( @ARGV ) );
}
foreach ( @match_options )
{
	print( "Matching '$_'\n" );
}

# Types
my %types =
(
	string => { db_type=>'string', hint=>'string', pattern=>qr|^(.+)$|, format=>q( $1 ) },
	alphanum => { db_type=>'string', hint=>'alphanumeric', pattern=>qr|^([a-zA-Z0-9-_]+)$|, format=>q( $1 ) },
	text => { db_type=>'text', hint=>'free text', pattern=>qr|^(.+)$|, format=>q( $1 ) },
	boolean => { db_type=>'boolean', hint=>'yes|no', pattern=>qr|^([yn])|i, check=>q( $1 ), format=>q( ($1 =~ /^y/) ? 'yes' : 'no' ) },
	integer => { db_type=>'integer', hint=>'integer', pattern=>qr|^(\d+)$|, format=>q( $1 ) },
	decimal => { db_type=>'decimal', hint=>'decimal', pattern=>qr|^(\d+(?:\.\d+)?)$|, format=>q( $1 ) },
	hexadecimal => { db_type=>'hexadecimal', hint=>'hexadecimal', pattern=>qr|^(?:0x)?([0-9a-f]{1,8})$|, format=>q( '0x'.$1 ) },
	abs_path => { db_type=>'string', hint=>'/absolute/path/to/somewhere', pattern=>qr|^((?:/[^/]*)+?)/?$|, format=>q( $1 ) },
	rel_path => { db_type=>'string', hint=>'relative/path/to/somewhere', pattern=>qr|^((?:[^/].*)?)/?$|, format=>q( $1 ) },
	directory => { db_type=>'string', hint=>'directory', pattern=>qr|^([a-zA-Z0-9-_.]+)$|, format=>q( $1 ) },
	file => { db_type=>'string', hint=>'filename', pattern=>qr|^([a-zA-Z0-9-_.]+)$|, format=>q( $1 ) },
	hostname => { db_type=>'string', hint=>'host.your.domain', pattern=>qr|^([a-zA-Z0-9_.-]+)$|, format=>q( $1 ) },
	url => { db_type=>'string', hint=>'http://host.your.domain/', pattern=>qr|^(?:http://)?(.+)$|, format=>q( 'http://'.$1 ) },
	email => { db_type=>'string', hint=>'your.name@your.domain', pattern=>qr|^([a-zA-Z0-9_.-]+)\@([a-zA-Z0-9_.-]+)$|, format=>q( $1\@$2" ) },
	include => { db_type=>'include', hint=>'local/path/to/file', pattern=>qr|^(.*)?$|, check=>q( -e $1 ), format=>q( $1 ) },
);

# Minor hack to get the right values out of configure.
my $prefix = "@prefix@";
my $exec_prefix = ${prefix};
my $bindir = "${exec_prefix}/bin";

my @options =
(
	{
		name => "ZM_VERSION",
		default => "@VERSION@",
		description => "ZoneMinder version number, autogenerated do not change",
		type => $types{string},
		readonly => 1,
		category => 'core',
	},
	{
		name => "ZM_PATH_BIN",
		default => "$bindir",
		description => "Path to the ZoneMinder executables, autogenerated do not change",
		help => "The path where the ZoneMinder executables are installed is set at configure time. This is a readonly option for the purposes of distributing this information around the various binaries and scripts that need to know it. Changing this option here will tend to break things. Instead re-run configure to regenerate the path.",
		type => $types{abs_path},
		readonly => 1,
		category => 'core',
	},
	{
		name => "ZM_PATH_WEB",
		default => "@WEB_PREFIX@",
		description => "Path to the ZoneMinder web files, autogenerated do not change",
		help => "The path where the ZoneMinder web files are installed is set at configure time. This is a readonly option for the purposes of distributing this information around the various binaries and scripts that need to know it. Changing this option here will tend to break things. Instead re-run configure to regenerate the path.",
		type => $types{abs_path},
		readonly => 1,
		category => 'core',
	},
	{
		name => "ZM_PATH_CGI",
		default => "@CGI_PREFIX@",
		description => "Path to the ZoneMinder cgi files, autogenerated do not change",
		help => "The path where the ZoneMinder cgi files are installed is set at configure time. This is a readonly option for the purposes of distributing this information around the various binaries and scripts that need to know it. Changing this option here will tend to break things. Instead re-run configure to regenerate the path.",
		type => $types{abs_path},
		readonly => 1,
		category => 'core',
	},
	{
		name => "ZM_WEB_USER",
		default => "@WEB_USER@",
		description => "User name of your httpd daemon user, autogenerated do not change",
		help => "The user name of your httpd daemon user is set at configure time. This is a readonly option for the purposes of distributing this information around the various binaries and scripts that need to know it. Changing this option here will tend to break things. Instead re-run configure to regenerate the user name.",
		type => $types{alphanum},
		readonly => 1,
		category => 'core',
	},
	{
		name => "ZM_WEB_GROUP",
		default => "@WEB_GROUP@",
		description => "User group of your httpd daemon user, autogenerated do not change",
		help => "The user group of your httpd daemon user is set at configure time. This is a readonly option for the purposes of distributing this information around the various binaries and scripts that need to know it. Changing this option here will tend to break things. Instead re-run configure to regenerate the user group.",
		type => $types{alphanum},
		readonly => 1,
		category => 'core',
	},
	{
		name => "ZM_DB_SERVER",
		default => "localhost",
		description => "Machine on which the database server is running",
		help => "This is the machine on which you have installed MySQL and which manages the database. For performance and convenience purposes this is usually on the same machine the web server is running on but can be elsewhere. Enter either your hostname or 'localhost' for this machine.",
		type => $types{hostname},
		category => 'core',
	},
	{
		name => "ZM_DB_NAME",
		default => "zm",
		description => "Database containing the tables",
		help => "This is the name of the MySQL database that will be used. Normally this will be just 'zm' though if you two or more installs you may wish to keep databases separate. To create this database just run the following command 'mysql < db/zmschema.sql'. You may need to give additional username and password parameters to MySQL to acquire sufficient privileges to create tables.",
		type => $types{alphanum},
		category => 'core',
	},
	{
		name => "ZM_DB_USERA",
		default => "",
		description => "Privileged DB user name, needs at least select, insert, update and delete privileges",
		help => "This is the username of a MySQL user that has full privileges to select, insert, update and delete data from your ZoneMinder database. If you have no user available yet you can create one by typing 'mysql mysql' with additional parameters as required to give you access. Then at the prompt type 'grant select,insert,update,delete on <your database name>.* to '<your username>' identified by '<your password>';'. Then type 'quit' to exit. You may also need to type 'mysqladmin reload' to ensure your changes take effect. Note that the username and passwords used here are not related to your Linux login or accounts and should not be the same.",
		type => $types{alphanum},
		category => 'core',
	},
	{
		name => "ZM_DB_PASSA",
		default => "",
		description => "Privileged DB user password",
		help => "This is the password of a MySQL user that has full privileges to select, insert, update and delete data from your ZoneMinder database. If you have no user available yet you can create one by typing 'mysql mysql' with additional parameters as required to give you access. Then at the prompt type 'grant select,insert,update,delete on <your database name>.* to '<your username>' identified by '<your password>';'. Then type 'quit' to exit. You may also need to type 'mysqladmin reload' to ensure your changes take effect. Note that the username and passwords used here are not related to your Linux login or accounts and should not be the same.",
		type => $types{alphanum},
		category => 'core',
	},
	{
		name => "ZM_DB_USERB",
		default => "",
		description => "Unprivileged DB user name, need just select privilege.",
		help => "This is the username of a MySQL user that has only privileges to select data from your ZoneMinder database and is used in cgi programs where full access is neither necessary or desiarable. If you have no user available yet you can create one by typing 'mysql mysql' with additional parameters as required to give you access. Then at the prompt type 'grant select on <your database name>.* to '<your username>' identified by '<your password>';'. Then type 'quit' to exit. You may also need to type 'mysqladmin reload' to ensure your changes take effect. Note that the username and passwords used here are not related to your Linux login or accounts and should not be the same.",
		type => $types{alphanum},
		category => 'core',
	},
	{
		name => "ZM_DB_PASSB",
		default => "",
		description => "Unprivileged DB user password",
		help => "This is the password of a MySQL user that has only privileges to select data from your ZoneMinder database and is used in cgi programs where full access is neither necessary or desiarable. If you have no user available yet you can create one by typing 'mysql mysql' with additional parameters as required to give you access. Then at the prompt type 'grant select on <your database name>.* to '<your username>' identified by '<your password>';'. Then type 'quit' to exit. You may also need to type 'mysqladmin reload' to ensure your changes take effect. Note that the username and passwords used here are not related to your Linux login or accounts and should not be the same.",
		type => $types{alphanum},
		category => 'core',
	},
	{
		name => "ZM_OPT_USE_AUTH",
		default => "no",
		introduction => "You have completed the options that are fixed in compilation. You can now continue and specify the remaining options or press 'x' to exit and save your changes and then edit the remainder from the web interface.",
		description => "Authenticate user logins to ZoneMinder",
		help => "ZoneMinder can run in two modes. The simplest is an entirely unauthenticated mode where anyone can access ZoneMinder and perform all tasks. This is most suitable for installation where the web server access is limited in other ways. The other mode enables user accounts with varying sets of permissions. Users must login to access ZoneMinder and are limited by their defined permissions.",
		type => $types{boolean},
		category => 'system',
	},
	{
		name => "ZM_DIR_EVENTS",
		default => "events",
		description => "Directory where events are stored",
		help => "This is the path to the events directory where all the event images and other miscellaneous files are stored. It is normally given as a subdirectory of the web directory you have specified earlier however if disk space is tight it can reside on another partition in which case you should create a link from that area to the path you give here.",
		type => $types{directory},
		category => 'paths',
	},
	{
		name => "ZM_DIR_IMAGES",
		default => "images",
		description => "Directory where the images that the ZoneMinder client generates are stored",
		help => "ZoneMinder generates a myriad of images, mosty of which are associated with events. For those that aren't this is where they go.",
		type => $types{directory},
		category => 'paths',
	},
	{
		name => "ZM_DIR_SOUNDS",
		default => "sounds",
		description => "Directory to the sounds that the ZoneMinder client can use",
		help => "ZoneMinder generates a myriad of images, mosty of which are associated with events. For those that aren't this is where they go.",
		type => $types{directory},
		category => 'paths',
	},
	{
		name => "ZM_PATH_ZMS",
		default => "/cgi-bin/zms",
		description => "Web path to zms streaming server",
		help => "The ZoneMinder streaming server is required to send streamed images to your browser. It will be installed into the cgi-bin path given at configuration time. This option determines what the web path to the server is rather than the local path on your machine.",
		type => $types{rel_path},
		category => 'paths',
	},
	{
		name => "ZM_OPT_CAMBOZOLA",
		default => "no",
		description => "Is the (optional) cambozola java streaming client installed (recommended)",
		help => "Cambozola is a handy low fat cheese flavoured Java applet that ZoneMinder uses to view image streams on browsers such as Internet Explorer that don't natively support this format. It is highly recommended to install this from http://www.charliemouse.com/code/cambozola/  however if it is not installed still images at a lower refresh rate can still be viewed.",
		type => $types{boolean},
		category => 'tools',
	},
	{
		name => "ZM_PATH_CAMBOZOLA",
		default => "cambozola.jar",
		description => "Web path to (optional) cambozola java streaming client (recommended)",
		help => "Cambozola is a handy low fat cheese flavoured Java applet that ZoneMinder uses to view image streams on browsers such as Internet Explorer that don't natively support this format. It is highly recommended to install this from http://www.charliemouse.com/code/cambozola/  however if it is not installed still images at a lower refresh rate can still be viewed. Leave this as 'cambozola.jar' if cambozola is installed in the same directory as the ZoneMinder web client files.",
		requires => [ { name=>"ZM_OPT_CAMBOZOLA", value=>"yes" } ],
		type => $types{rel_path},
		category => 'tools',
	},
	{
		name => "ZM_CAN_STREAM",
		default => "no",
		description => "Override the detection of streaming capability by browser",
		help => "If you know that your browser can handle image streams of the type 'multipart/x-mixed-replace' but ZoneMinder does not detect this correctly you can set this option to ensure that the stream is delivered without the use of the Cambozola plugin.",
		type => $types{boolean},
		category => 'tools',
	},
	{
		name => "ZM_LOCAL_BGR_INVERT",
		default => "yes",
		description => "Invert BGR colours to RGB",
		help => "Some cameras or video cards capture images in BGR (Blue-Green-Red) order even when the paletter says RGB. If you see strange colours casts on your images then it may be worth trying this option to see if that corrects the issue. Note this option will apply only to local cameras and not those over a network.",
		type => $types{boolean},
		category => 'video',
	},
	{
		name => "ZM_FAST_RGB_DIFFS",
		default => "yes",
		description => "Whether we use a rough RGB difference algorithm",
		help => "When ZoneMinder tries to establish the differences between two colour images it generates a greyscale 'delta' image between the two sets of images. In order to do this it merges the differences found between the different RGB colour components. If this option is set then the resulting difference is determined as the average of the differences of each colour which is a simple fast calculation. If this option is not set then a calculation will be made to convert each pixel of the image into a brightness value (Y from YUV) and then find the difference between the two. This is a more accurate but potentially slower calculation.",
		type => $types{boolean},
		category => 'video',
	},
	{
		name => "ZM_COLOUR_JPEG_FILES",
		default => "yes",
		description => "Colourise greyscale JPEG files",
		help => "Cameras that capture in greyscale can write their captured images to jpeg files with a corresponding greyscale colour space. This saves a small amount of disk space over colour ones. However some tools such as ffmpeg and mpeg_encode either fail to work with this colour space or have to convert it beforehand. Setting this option to yes uses up a little more space but makes creation of MPGE files much faster.",
		type => $types{boolean},
		category => 'video',
	},
	{
		name => "ZM_JPEG_FILE_QUALITY",
		default => "70",
		description => "Set the JPEG quality setting for the saved event files (1-100)",
		help => "When ZoneMinder detects an event it will save the images associated with that event to files. These files are in the JPEG format and can be viewed or streamed later. This option specifies what image quality should be used to save these files. A higher number means better quality but less compression so will take up more disk space and take longer to view over a slow connection. By contrast a low number means smaller, quicker to view, files but at the price of lower quality images.",
		type => $types{integer},
		category => 'video',
	},
	{
		name => "ZM_JPEG_IMAGE_QUALITY",
		default => "70",
		description => "Set the JPEG quality setting for the streamed 'live' images (1-100)",
		help => "When viewing a 'live' stream for a monitor ZoneMinder will grab an image from the buffer and encode it into JPEG format before sending it. This option specifies what image quality should be used to encode these images. A higher number means better quality but less compression so will take longer to view over a slow connection. By contrast a low number means quicker to view files but at the price of lower quality images. This option does not apply when viewing still images as these are just read from disk and so will be encoded at the quality specified by the previous option.",
		type => $types{integer},
		category => 'video',
	},
	{
		name => "ZM_BLEND_ALARMED_IMAGES",
		default => "yes",
		description => "Whether alarmed images are blended to update the reference image",
		help => "To detect alarms ZoneMinder compares an image with a reference image which is formed from a composite of the previous images. This option determines whether images that cause events are included in this process. Doing so may increase the precision of the alarmed region but can cause problems if wholescale lighting changes cause alarms as this would not get fed back into the image and an alarm may persist indefinately. A better way to achive the same effect in most cases is to lower substantially the reference blend persentage in specific monitors..",
		type => $types{boolean},
		category => 'video',
	},
	{
		name => "ZM_NO_MAX_FPS_ON_ALARM",
		default => "yes",
		description => "Should any Maximum FPS be ignored if an alarm occurs",
		help => "When configuring monitors you can optionally specify a maximum setting for the capture rate rate in frames per second. This can used to limit your video or network bandwidth or reduce CPU load. This setting tells ZoneMinder to ignore these constraints if an alarm is detected an attempt to capture as fast as possible.",
		type => $types{boolean},
		category => 'video',
	},
	{
		name => "ZM_OPT_ADAPTIVE_SKIP",
		default => "yes",
		description => "Should frame analysis try and be efficient in skipping frames",
		help => "In previous versions of ZoneMinder the analysis daemon would attempt to keep up with the capture daemon by processing the last captured frame on each pass. This would sometimes have the undesirable side-effect of missing a chunk of the initial activity that caused the alarm because the pre-alarm frames would all have to be written to disk and the database before processing the next frame, leading to some delay between the first and second event frames. Setting this option enables a newer adaptive algorithm where the analysis daemon attempts to process as many captured frames as possible, only skipping frames when in danger of the capture daemon overwriting yet to be processed frames. This skip is variable depending on the size of the ring buffer and the amount of space left in it. Enabling this option will give you much better coverage of the beginning of alarms whilst biasing out any skipped frames towards the middle or end of the event. However you should be aware that this will have the effect of making the analysis daemon run somewhat behind the capture daemon during events and for particularly fast rates of capture it is possible for the adaptive algorithm to be overwhelmed and not have time to react to a rapid build up of pending frames and thus for a buffer overrun condition to occur.",
		type => $types{boolean},
		category => 'video',
	},
	{
		name => "ZM_OPT_FRAME_SERVER",
		default => "no",
		description => "Should analysis farm out the writing of images to disk",
		#requires => [ { name => "ZM_OPT_ADAPTIVE_SKIP", value => "yes" } ],
		help => "In some circumstances it is possible for a slow disk to take so long writing images to disk that it causes the analysis daemon to fall behind especially during hig frame rate events. Setting this option to yes enables a frame server daemon (zmf) which will be sent the images from the analysis daemon and will do the actual writing of images itself freeing up the analysis daemon to get on with other things. Should this transmission fail or other permanent or transient error occur, this function will fall back to the analysis daemon.",
		type => $types{boolean},
		category => 'video',
	},
	{
		name => "ZM_OPT_REMOTE_CAMERAS",
		default => "no",
		description => "Are you going to use remote/networked cameras",
		help => "ZoneMinder can work with both local cameras, ie. those attached physically to your computer and remote or network cameras. If you will be using networked cameras select this option.",
		type => $types{boolean},
		category => 'network',
	},
	{
		name => "ZM_HTTP_VERSION",
		default => "1.1",
		description => "The version of HTTP that ZoneMinder will use to connect",
		requires => [ { name => "ZM_OPT_REMOTE_CAMERAS", value => "yes" } ],
		help => "ZoneMinder can communicate using either of the HTTP/1.1 or HTTP/1.0 standard. A server will normally fall back to the version it supports iwht no problem so this should usually by left at the default. However it can be changed to HTTP/1.0 if necessary to resolve particular issues.",
		type => { db_type=>'string', hint=>'1.1|1.0', pattern=>qr|^(1\.[01])$|, format=>q( $1?$1:"" ) },
		category => 'network',
	},
	{
		name => "ZM_HTTP_UA",
		default => "ZoneMinder",
		description => "The user agent that ZoneMinder uses to identify itself",
		requires => [ { name => "ZM_OPT_REMOTE_CAMERAS", value => "yes" } ],
		help => "When ZoneMinder communicates with remote cameras it will identify itself using this string and it's version number. This is normally sufficient, however if a particular cameras expects only to communicate with certain browsers then this can be changed to a different string identifying ZoneMinder as Internet Explorer or Netscape etc.",
		type => $types{string},
		category => 'network',
	},
	{
		name => "ZM_HTTP_TIMEOUT",
		default => "2500",
		description => "How long ZoneMinder waits before giving up on images (millseconds)",
		requires => [ { name => "ZM_OPT_REMOTE_CAMERAS", value => "yes" } ],
		help => "When retrieving remote images ZoneMinder will wait for this length of time before deciding that an image is not going to arrive and taking steps to retry. This timeout is in milliseconds (1000 per second) and will apply to each part of an image if it is not sent in one whole chunk.",
		type => $types{integer},
		category => 'network',
	},
	{
		name => "ZM_OPT_MPEG",
		default => "no",
		description => "Is there an (optional) mpeg video encoder installed",
		help => "ZoneMinder can optionally encode a series of video images into an MPEG encoded file. This option allows you to specifiy whether you have an mpeg encoder installed and if so which one. The two that ZoneMinder supports are mpeg_encode and ffmpeg, of which the latter is by far the fastest. However creating MPEG files can be fairly CPU and disk intensive and is not required as events can still be reviewed as video stream without it.",
		type => { db_type=>'string', hint=>'no|mpeg_encode|ffmpeg', pattern=>qr|^([nmf])|i, format=>q( $1 =~ /^n/ ? 'no' : ( $1 =~ /^m/ ? 'mpeg_encode' : 'ffmpeg') ) },
		category => 'tools',
	},
	{
		name => "ZM_PATH_MPEG_ENCODE",
		default => "/usr/local/bin/mpeg_encode",
		description => "Path to (optional) Berkeley mpeg encoder",
		help => "This path should point to where the Berkeley mpeg_encode program has been installed.",
		requires => [ { name=>"ZM_OPT_MPEG", value=>"mpeg_encode" } ],
		type => $types{abs_path},
		category => 'tools',
	},
	{
		name => "ZM_PATH_FFMPEG",
		default => "/usr/local/bin/ffmpeg",
		description => "Path to (optional) ffmpeg mpeg encoder",
		help => "This path should point to where the ffmpeg has been installed.",
		requires => [ { name=>"ZM_OPT_MPEG", value=>"ffmpeg" } ],
		type => $types{abs_path},
		category => 'tools',
	},
	{
		name => "ZM_FFMPEG_OPTIONS",
		default => "-hq -intra",
		description => "Additional options to ffmpeg",
		help => "Ffmpeg can take many options on the command line to control the quality of video produced. This option allows you to specify your own set. Check the ffmpeg documentation for the meaning of these and other options.",
		requires => [ { name=>"ZM_OPT_MPEG", value=>"ffmpeg" } ],
		type => $types{string},
		category => 'tools',
	},
	{
		name => "ZM_OPT_NETPBM",
		default => "no",
		description => "Are the (optional) Netpbm utilities installed",
		help => "For low bandwidth situations ZoneMinder will resize images into thumbnails on the fly before sending them to the browser to reduce the network traffic at the expense of CPU on the server. It uses the Netpbm package to do this and this option should be set to where the binaries from that package are installed. If you do not have it installed it means that the images will always be sent full sizxe and rescaled on your browser whioch may or not be an isue for you.",
		type => $types{boolean},
		category => 'tools',
	},
	{
		name => "ZM_PATH_NETPBM",
		default => "/usr/bin",
		description => "Path to (optional) Netpbm utilities",
		help => "For low bandwidth situations ZoneMinder will resize images into thumbnails on the fly before sending them to the browser to reduce the network traffic at the expense of CPU on the server. It uses the Netpbm package to do this and this option should be set to where the binaries from that package are installed. If you do not have it installed it means that the images will always be sent full sizxe and rescaled on your browser whioch may or not be an isue for you.",
		requires => [ { name=>"ZM_OPT_NETPBM", value=>"yes" } ],
		type => $types{abs_path},
		category => 'tools',
	},
	{
		name => "ZM_PATH_SOCKS",
		default => "/tmp",
		description => "Path to the various Unix domain socket files that ZoneMinder uses",
		help => "ZoneMinder generally uses Unix domain sockets where possible. This reduces the need for port assignments and prevents external applications from possibly compromising the daemons. However each Unix socket requires a .sock file to be created. This option where those socket files go.",
		type => $types{abs_path},
		category => 'paths',
	},
	{
		name => "ZM_PATH_LOGS",
		default => "/tmp",
		description => "Path to the various logs that the ZoneMinder daemons generate",
		help => "There are various daemons that are used by ZoneMinder to perform various tasks. Most generate helpful log files and this is where they go. They can be deleted if not required for debugging.",
		type => $types{abs_path},
		category => 'paths',
	},
	{
		name => "ZM_WEB_POPUP_ON_ALARM",
		default => "yes",
		description => "Should the monitor window jump to the top if an alarm occurs",
		help => "When viewing a live monitor stream you can specify whether you want the window to pop to the front if an alarm occurs when the window is minimised or behind another window. This is most useful if your monitors are over doors for example when they can pop up if someone comes to the doorway.",
		type => $types{boolean},
		category => 'web',
	},
	{
		name => "ZM_OPT_X10",
		default => "no",
		description => "Whether we want to interface with X10 devices",
		help => "If you have an X10 Home Automation setup in your home you can use ZoneMinder to initiate or react to X10 signals if your computer has the appropriate interface controller. This option indicates whether X10 options will be available in the browser client.",
		type => $types{boolean},
		category => 'x10',
	},
	{
		name => "ZM_X10_DEVICE",
		default => "/dev/ttyS0",
		description => "What device is your X10 controller connected on",
		requires => [ { name => "ZM_OPT_X10", value => "yes" } ],
		help => "If you have an X10 controller device (e.g. XM10U) connected to your computer this option details which port it is conected on, the default of /dev/ttyS0 maps to serial or com port 1.",
		type => $types{abs_path},
		category => 'x10',
	},
	{
		name => "ZM_X10_HOUSE_CODE",
		default => "A",
		description => "What X10 house code should be used",
		requires => [ { name => "ZM_OPT_X10", value => "yes" } ],
		help => "X10 devices are grouped together by identifying them as all belonging to one House Code. This option details what that is. It should be a single letter between A and P.",
		type => { db_type=>'string', hint=>'A-P', pattern=>qr|^([A-P])|i, format=>q( uc($1) ) },
		category => 'x10',
	},
	{
		name => "ZM_X10_DB_RELOAD_INTERVAL",
		default => "60",
		description => "How often (in seconds) the X10 damon reloads the monitors from the database",
		requires => [ { name => "ZM_OPT_X10", value => "yes" } ],
		help => "The zmx10 daemon periodically checks the database to find out what X10 events trigger, or result from, alarms. This option determines how frequently this check occurs, unless you change this area frequently this can be a fairly large value.",
		type => $types{integer},
		category => 'x10',
	},
	{
		name => "ZM_WEB_SOUND_ON_ALARM",
		default => "no",
		description => "Should the monitor window play an alarm sound if an alarm occurs",
		help => "When viewing a live monitor stream you can specify whether you want the window to play a sound to alert you if an alarm occurs.",
		type => $types{boolean},
		category => 'web',
	},
	{
		name => "ZM_WEB_ALARM_SOUND",
		default => "",
		description => "The sound to play on alarm, put this in the sounds directory",
		help => "You can specify a sound file to play if an alarm occurs whilst you are watching a live monitor stream. So long as your browser understands the format it does not need to be any particular type. This file should be placed in the sounds directory defined earlier.",
		type => $types{file},
		requires => [ { name => "ZM_WEB_SOUND_ON_ALARM", value => "yes" } ],
		category => 'web',
	},
	{
		name => "ZM_WEB_MONTAGE_MAX_COLS",
		default => "2",
		description => "The maximum number of monitor columns in the montage view",
		help => "The 'montage' view shows images from all your monitors at once. This parameter defines how many monitors to place across your screen before moving to the next row. If you have a very wide screen and/or small images from your cameras this can be a bigger value however if not, of if you prefer the images stacked vertically it should be small.",
		type => $types{integer},
		category => 'web',
	},
	{
		name => "ZM_OPT_FAST_DELETE",
		default => "yes",
		description => "When deleting events should the client only delete the database records for speed",
		help => "Normally an event created as the result of an alarm consists of entries in one or more database tables plus the various files associated with it. When deleting events in the browser it can take a long time to remove all of this if your are trying to do a lot of events at once. It is recommended that you set this option which means that the browser client only deletes the key entries in the events table, which means the events will no longer appear in listing, and leaves the zmaudit daemon to clear up the rest later.",
		type => $types{boolean},
		category => 'system',
	},
	{
		name => "ZM_STRICT_VIDEO_CONFIG",
		default => "yes",
		description => "Whether to allow errors in setting video config to be fatal",
		help => "With some video devices errors can be reported in setting the various video attributes when in fact the operation was successful. Switching this option off will still allow these errors to be reported but will not cause them to kill the video capture daemon. Note however that doing this will cause all errors to be ignored including those which are genuine and which may cause the video capture to not function correctly. Use this option with caution.",
		type => $types{boolean},
		category => 'video',
	},
	{
		name => "ZM_SHM_KEY",
		default => "0x7a6d2000",
		description => "Shared memory key to use, only change if it clashes with another application",
		help => "ZoneMinder uses shared memory to speed up communication between modules. To identify the right area to use shared memory keys are used. This option controls what the base key is, each monitor will have it's Id or'ed with this to get the actual key used.",
		type => $types{hexadecimal},
		category => 'system',
	},
	{
		name => "ZM_FILTER_RELOAD_DELAY",
		default => "300",
		description => "How often (in seconds) filters are reloaded in zmfilter.pl",
		help => "ZoneMinder allows you to save filters to the database which allow events that match certain criteria to be deleted or uploaded to a remote machine. The zmfilter daemon loads these and does the deleting or uploading. This option determine how often the filters are reloaded to get the latest versions of the filters. If you don't change filters very often this can be quite large.",
		type => $types{integer},
		category => 'system',
	},
	{
		name => "ZM_OPT_UPLOAD",
		default => "no",
		description => "Should ZoneMinder try and upload events that match corresponding filters",
		help => "In ZoneMinder you can create event filters that specify whether events that match certain criteria should be uploaded to a remote server for archiving. This option specifies whether this functionality should be available",
		type => $types{boolean},
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_ARCH_FORMAT",
		default => "tar",
		description => "What format the uploaded events should be created in. This can be 'tar' or 'zip'",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		help => "Uploaded events may be stored in either .tar or .zip format, this option specifies which. Note that to use this you will need to have the Archive::Tar and/or Archive::Zip perl modules installed.",
		type => { db_type=>'string', hint=>'tar|zip', pattern=>qr|^([tz])|i, format=>q( $1 =~ /^t/ ? 'tar' : 'zip' ) },
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_ARCH_COMPRESS",
		default => "no",
		description => "Should archive files be compressed",
		help => "When the archive files are created they can be compressed. However in general since the images are compressed already this saves only a minimal amount of space versus utilising more CPU in their creation. Only enable if you have CPU to waste and are limited in disk space on your remote server or bandwidth",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		type => $types{boolean},
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_ARCH_ANALYSE",
		default => "no",
		description => "Whether to include the analysis files in the archive, bigger but slower",
		help => "When the archive files are created they can contain either just the captured frames or both the captured frames and for frames that caused an alarm the analysed image with the changed area highlighted. This option controls which to do. Only included analysed frames if you have a high bandwidth connection to the remote server or if you need help in figuring out what caused an alarm in the first place",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		type => $types{boolean},
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_FTP_HOST",
		default => "",
		description => "The remote server to upload to",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		help => "This is the remote machine that you wish to upload archived events to.",
		type => $types{hostname},
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_FTP_USER",
		default => "",
		description => "Your ftp username",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		type => $types{alphanum},
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_FTP_PASS",
		default => "",
		description => "Your ftp password",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		type => $types{string},
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_FTP_LOC_DIR",
		default => "/tmp",
		description => "The local directory in which to create upload files",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		type => $types{abs_path},
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_FTP_REM_DIR",
		default => "",
		description => "The remote directory to upload to",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		type => $types{rel_path},
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_FTP_TIMEOUT",
		default => "120",
		description => "How long (in seconds) we allow the transfer to take for each file",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		type => $types{integer},
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_FTP_PASSIVE",
		default => "yes",
		description => "Whether to use passive ftp",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		help => "If your computer is behind a firewall or proxy you may need to set FTP to passive mode. In fact for simple transfers it makes little sense to do otherwise anyway but you can set this to 'No' if you wish.",
		type => $types{boolean},
		category => 'ftp',
	},
	{
		name => "ZM_UPLOAD_FTP_DEBUG",
		default => "yes",
		description => "Whether to switch ftp debugging on",
		requires => [ { name => "ZM_OPT_UPLOAD", value => "yes" } ],
		help => "If you are having (or expecting) troubles with uploading archived events then setting this to 'yes' permits additional information to be included in the zmfilter log file.",
		type => $types{boolean},
		category => 'ftp',
	},
	{
		name => "ZM_OPT_EMAIL",
		default => "no",
		description => "Should ZoneMinder email you details of events that match corresponding filters",
		help => "In ZoneMinder you can create event filters that specify whether events that match certain criteria should have their details emailed to you at a designated email address. This will allow you to be notified of events as soon as they occur and also to quickly view the events directly. This option specifies whether this functionality should be available. The email created with this option can be any size and is intended to be sent to a regular email reader rather than a mobile device.",
		type => $types{boolean},
		category => 'mail',
	},
	{
		name => "ZM_EMAIL_ADDRESS",
		default => "",
		description => "The email address to send matching event details to",
		requires => [ { name => "ZM_OPT_EMAIL", value => "yes" } ],
		help => "This option is used to define the email address that any events that match the appropriate filters will be sent to.",
		type => $types{email},
		category => 'mail',
	},
	{
		name => "ZM_EMAIL_FORMAT",
		default => "zmconfig_eml.txt",
		description => "The format of the email used to send matching event details",
		requires => [ { name => "ZM_OPT_EMAIL", value => "yes" } ],
		help => "This option is used to define the file that contains the format of the email that is sent for any events that match the appropriate filters.",
		type => $types{include},
		category => 'mail',
	},
	{
		name => "ZM_EMAIL_TEXT",
		default => "",
		description => "The text of the email used to send matching event details",
		requires => [ { name => "ZM_OPT_EMAIL", value => "yes" } ],
		help => "This option is used to define the content of the email that is sent for any events that match the appropriate filters.",
		type => $types{text},
		category => 'mail',
		readonly => 1,
	},
	{
		name => "ZM_OPT_MESSAGE",
		default => "no",
		description => "Should ZoneMinder message you with details of events that match corresponding filters",
		help => "In ZoneMinder you can create event filters that specify whether events that match certain criteria should have their details sent to you at a designated short message email address. This will allow you to be notified of events as soon as they occur. This option specifies whether this functionality should be available. The email created by this option will be brief and is intended to be sent to an SMS gateway or a minimal mail reader such as a mobile device or phone rather than a regular email reader.",
		type => $types{boolean},
		category => 'mail',
	},
	{
		name => "ZM_MESSAGE_ADDRESS",
		default => "",
		description => "The email address to send matching event details to",
		requires => [ { name => "ZM_OPT_MESSAGE", value => "yes" } ],
		help => "This option is used to define the short message email address that any events that match the appropriate filters will be sent to.",
		type => $types{email},
		category => 'mail',
	},
	{
		name => "ZM_MESSAGE_FORMAT",
		default => "zmconfig_msg.txt",
		description => "The format of the message used to send matching event details",
		requires => [ { name => "ZM_OPT_MESSAGE", value => "yes" } ],
		help => "This option is used to define the file that contains the format of the message that is sent for any events that match the appropriate filters.",
		type => $types{include},
		category => 'mail',
	},
	{
		name => "ZM_MESSAGE_TEXT",
		default => "",
		description => "The text of the message used to send matching event details",
		requires => [ { name => "ZM_OPT_MESSAGE", value => "yes" } ],
		help => "This option is used to define the content of the message that is sent for any events that match the appropriate filters.",
		type => $types{text},
		category => 'mail',
		readonly => 1,
	},
	{
		name => "ZM_EMAIL_METHOD",
		default => "sendmail",
		description => "The method your machine uses to send email and messages",
		requires => [ { name => "ZM_OPT_EMAIL", value => "yes" }, { name => "ZM_OPT_MESSAGE", value => "yes" } ],
		help => "ZoneMinder needs to know how to send you the notification emails or messages. This option tell it which method to use, generally sendmail will work if configured correctly on your machine, otherwise choose smtp and then give your mail host address in the next option.",
		type => { db_type=>'string', hint=>'sendmail|smtp', pattern=>qr|^(se\|sm)|i, format=>q( $1 =~ /^se/ ? 'sendmail' : 'smtp' ) },
		category => 'mail',
	},
	{
		name => "ZM_EMAIL_HOST",
		default => "localhost",
		description => "The host address of your SMTP mail server",
		requires => [ { name => "ZM_EMAIL_METHOD", value => "smtp" } ],
		help => "If you have chosen SMTP as the method by which to send notification emails or messages then this option allows you to choose which SMTP server to use to send them. The default of localhost may work if you have the sendmail, exim or a similar daemon running however you may wish to enter your ISP's SMTP mail server here.",
		type => $types{hostname},
		category => 'mail',
	},
	{
		name => "ZM_FROM_EMAIL",
		default => "",
		description => "The email address you wish your event notifications to originate from",
		requires => [ { name => "ZM_OPT_EMAIL", value => "yes" }, { name => "ZM_OPT_MESSAGE", value => "yes" } ],
		help => "The emails or messages that will be sent to you informing you of events can appear to come from a designated email address to help you with mail filtering etc. An address of something like ZoneMinder\@your.domain is recommended.",
		type => $types{email},
		category => 'mail',
	},
	{
		name => "ZM_URL",
		default => "",
		description => "The URL of your ZoneMinder installation",
		requires => [ { name => "ZM_OPT_EMAIL", value => "yes" }, { name => "ZM_OPT_MESSAGE", value => "yes" } ],
		help => "The emails or messages that will be sent to you informing you of events can include a link to the events themselves for easy viewing. If you intend to use this feature then set this option to the url of your installation as it would appear from where you read your email, e.g. http://host.your.domain/zm.php.",
		type => $types{url},
		category => 'mail',
	},
	{
		name => "ZM_WATCH_CHECK_INTERVAL",
		default => "10",
		description => "How often to check the capture daemons have not locked up",
		help => "The zmwatch daemon checks the image capture performance of the capture daemons to ensure that they have not locked up (rarely a sync error may occur which blocks indefinately). This option determines how often the daemons are checked.",
		type => $types{integer},
		category => 'system',
	},
	{
		name => "ZM_WATCH_MAX_DELAY",
		default => "15",
		description => "The maximum delay since the last captured image we will allow before restarting the capture daemons",
		help => "The zmwatch daemon checks the image capture performance of the capture daemons to ensure that they have not locked up (rarely a sync error may occur which blocks indefinately). This option determines the maximum delay we will allow since the last captured frame. The daemon will be restarted if it has not captured any images after this period though the actual restart may take slightly longer in conjunction with the check interval value above.",
		type => $types{decimal},
		category => 'system',
	},
	{
		name => "ZM_FORCED_ALARM_SCORE",
		default => "255",
		description => "Score to give forced alarms",
		help => "The 'zmu' utility can be used to force an alarm on a monitor rather than rely on the motion detection algorithms. This option determines what score to give these alarms to distinguish them from regular ones. It must be 255 or less.",
		type => $types{integer},
		category => 'video',
	},
	{
		name => "ZM_RECORD_EVENT_STATS",
		default => "yes",
		description => "Whether to record event statistical information, switch off if too slow",
		help => "This version of ZoneMinder records detailed information about events in the Stats table. This can help in profiling what the optimum settings are for Zones though this is tricky at present. However in future releases this will be done more easily and intuitively, especially with a large sample of events. The default option of 'yes' allows this information to be collected now in readiness for this but if you are concerned about performance you can switch this off in which case no Stats information will be saved.",
		type => $types{boolean},
		category => 'system',
	},
	{
		name => "ZM_WEB_REFRESH_METHOD",
		default => "javascript",
		description => "What method windows should use to refresh themselves, choose either javascript or http",
		help => "Many windows in Javascript need to refresh themselves to keep their information current. This option determines what method they should use to do this. Choosing 'javascript' means that each window will have a short JavaScript statement in with a timer to prompt the refresh. This is the most compatible method. Choosing 'http' means the refresh instruction is put in the HTTP header. This is a cleaner method but refreshes are interrupted or cancelled when a link in the window is clicked meaning that the window will no longer refresh and this would have to be done manually.",
		type => { db_type=>'string', hint=>'javascript|http', pattern=>qr|^([jh])|i, format=>q( $1 =~ /^j/ ? 'javascript' : 'http' ) },
		category => 'web',
	},
	{
		name => "ZM_WEB_H_REFRESH_MAIN",
		default => "300",
		introduction => "There are now a number of options that are grouped into bandwidth categories, this allows you to configure the ZoneMinder client to work optimally over the various access methods you might to access the client.\n\nThe next few options control what happens when the client is running in 'high' bandwidth mode. You should set these options for when accessing the ZoneMinder client over a local network or high speed link. In most cases the default values will be suitable as a starting point.",
		description => "How often (in seconds) the main console window should refresh itself",
		help => "The main console window lists a general status and the event totals for all monitors. This is not a trivial task and should not be repeated too frequently or it may affect the performance of the rest of the system.",
		type => $types{integer},
		category => 'highband',
	},
	{
		name => "ZM_WEB_H_REFRESH_CYCLE",
		default => "2",
		description => "How often (in seconds) the cycle watch window swaps to the next monitor",
		help => "The cycle watch window is a method of continuously cycling between still images from all of your monitors. This option determines how often to refresh with a new image.",
		type => $types{integer},
		category => 'highband',
	},
	{
		name => "ZM_WEB_H_REFRESH_IMAGE",
		default => "5",
		description => "How often (in seconds) the watched image is refreshed (if not streaming)",
		help => "The live images from a monitor can be viewed in either streamed or stills mode. This option determines how often a stills image is refreshed, it has no effect if streaming is selected.",
		type => $types{integer},
		category => 'highband',
	},
	{
		name => "ZM_WEB_H_REFRESH_STATUS",
		default => "3",
		description => "How often (in seconds) the status frame refreshes itself in the watch window",
		help => "The monitor window is actually made from several frames. The one in the middle merely contains a monitor status which needs to refresh fairly frequently to give a true indication. This option determines that frequency.",
		type => $types{integer},
		category => 'highband',
	},
	{
		name => "ZM_WEB_H_REFRESH_EVENTS",
		default => "30",
		description => "How often (in seconds) the event listing is refreshed in the watch window",
		help => "The monitor window is actually made from several frames. The lower framme contains a listing of the last few events for easy access. This option determines how often this is refreshed.",
		type => $types{integer},
		category => 'highband',
	},
	{
		name => "ZM_WEB_H_STREAM_IDLE_DELAY",
		default => "250",
		description => "How long (in milliseconds) between streamed frames in the watch window",
		help => "The top frame of the monitor window when monitoring a live feed in streaming mode contains a continuous stream of images. This option controls how often a new frame is sent to the browser when the monitor is idle, ie. not in alarm state. It makes little sense to set this too small as if it results in frames being sent much faster than they are being captured you will just get the same ones over and over. It should be set to be less or equal to the capture rate of the cameras you are using which will normally be between 2 and 25 Frames Per Second which maps to values between 500 and 40 being used here though your bandwidth may well limit how much can actually be sent. Note also that this is the update rate when no alarms are being generated, if an alarm situation occurs then the rate speeds up as per the next option so this can be set to a longer delay without you missing anything.",
		type => $types{integer},
		category => 'highband',
	},
	{
		name => "ZM_WEB_H_STREAM_FRAME_DELAY",
		default => "50",
		description => "How long (in milliseconds) to wait before looking for the next streamed frame",
		help => "The top frame of the monitor window when monitoring a live feed in streaming mode contains a continuous stream of images. This option controls how often a new frame is sent to the browser when an alarm is being generated. It makes little sense to set this too small as if it results in frames being sent much faster than they are being captured you will just get the same ones over and over. It should be set to roughly match the capture rate of the cameras you are using which will normally be between 2 and 25 Frames Per Second which maps to values between 500 and 40 being used here though your bandwidth may well limit how much can actually be sent.",
		type => $types{integer},
		category => 'highband',
	},
	{
		name => "ZM_WEB_H_STREAM_EVENT_DELAY",
		default => "-1",
		description => "How long to wait between each frame when streaming events",
		help => "When viewing a captured event this option controls how fast frames are sent to the browser. If this is a positive value then this represents the interval in milliseconds between each frame and should roughly match your capture rate otherwise the event may appear too fast or too slow. If zero then frames are sent as fast as possible. If this value is negative then the frames are sent at a rate proportional to the real interval at which they were captured, bandwidth permitting. Thus the default of -1 will try to send the frames at a real-time rate, -2 will be double real-time etc.",
		type => $types{integer},
		category => 'highband',
	},
	{
		name => "ZM_WEB_H_IMAGE_SCALING",
		default => "1",
		description => "How to scale thumbnails in events, bandwidth versus cpu in rescaling",
		help => "A value of 1 sends the whole image to the browser which resizes it in the window, larger values scale down by that amount on the server before sending a reduced size image to the browser. For high bandwidth settings the default of 1 is usally the fastest does not result in extraneous thumbnail files being generated.",
		type => $types{integer},
		requires => [ { name=>"ZM_PATH_NETPBM", value=>'/' } ],
		category => 'highband',
	},
	{
		name => "ZM_WEB_M_REFRESH_MAIN",
		default => "300",
		description => "How often (in seconds) the main console window should refresh itself",
		help => "The main console window lists a general status and the event totals for all monitors. This is not a trivial task and should not be repeated too frequently or it may affect the performance of the rest of the system.",
		type => $types{integer},
		introduction => "The next few options control what happens when the client is running in 'medium' bandwidth mode. You should set these options for when accessing the ZoneMinder client over a slower cable or DSL link. In most cases the default values will be suitable as a starting point.",
		category => 'medband',
	},
	{
		name => "ZM_WEB_M_REFRESH_CYCLE",
		default => "5",
		description => "How often (in seconds) the cycle watch window swaps to the next monitor",
		help => "The cycle watch window is a method of continuously cycling between still images from all of your monitors. This option determines how often to refresh with a new image.",
		type => $types{integer},
		category => 'medband',
	},
	{
		name => "ZM_WEB_M_REFRESH_IMAGE",
		default => "15",
		description => "How often (in seconds) the watched image is refreshed (if not streaming)",
		help => "The live images from a monitor can be viewed in either streamed or stills mode. This option determines how often a stills image is refreshed, it has no effect if streaming is selected.",
		type => $types{integer},
		category => 'medband',
	},
	{
		name => "ZM_WEB_M_REFRESH_STATUS",
		default => "5",
		description => "How often (in seconds) the status frame refreshes itself in the watch window",
		help => "The monitor window is actually made from several frames. The one in the middle merely contains a monitor status which needs to refresh fairly frequently to give a true indication. This option determines that frequency.",
		type => $types{integer},
		category => 'medband',
	},
	{
		name => "ZM_WEB_M_REFRESH_EVENTS",
		default => "60",
		description => "How often (in seconds) the event listing is refreshed in the watch window",
		help => "The monitor window is actually made from several frames. The lower framme contains a listing of the last few events for easy access. This option determines how often this is refreshed.",
		type => $types{integer},
		category => 'medband',
	},
	{
		name => "ZM_WEB_M_STREAM_IDLE_DELAY",
		default => "2500",
		description => "How long (in milliseconds) between streamed frames in the watch window",
		help => "The top frame of the monitor window when monitoring a live feed in streaming mode contains a continuous stream of images. This option controls how often a new frame is sent to the browser when the monitor is idle, ie. not in alarm state. It makes little sense to set this too small as if it exceeds the available bandwidth and results in frames being sent much faster than they are able to be displayed. In medium bandwidth mode it should be set to be rather less than the capture rate of the cameras you are using. Note also that this is the update rate when no alarms are being generated, if an alarm situation occurs then the rate speeds up as per the next option so this can be set to a longer delay without you missing anything.",
		type => $types{integer},
		category => 'medband',
	},
	{
		name => "ZM_WEB_M_STREAM_FRAME_DELAY",
		default => "100",
		description => "How long (in milliseconds) to wait before looking for the next streamed frame",
		help => "The top frame of the monitor window when monitoring a live feed in streaming mode contains a continuous stream of images. This option controls how often a new frame is sent to the browser when an alarm is being generated. It makes little sense to set this too small as if it exceeds the available bandwidth and results in frames being sent much faster than they are able to be displayed though as should be only for a short period it may be possible to catch up. In medium bandwidth mode it should be set to maybe half the capture rate of the cameras you are using.",
		type => $types{integer},
		category => 'medband',
	},
	{
		name => "ZM_WEB_M_STREAM_EVENT_DELAY",
		default => "-1",
		description => "How long to wait between each frame when streaming events",
		help => "When viewing a captured event this option controls how fast frames are sent to the browser. If this is a positive value then this represents the interval in milliseconds between each frame and should roughly match your capture rate otherwise the event may appear too fast or too slow. If zero then frames are sent as fast as possible. If this value is negative then the frames are sent at a rate proportional to the real interval at which they were captured, bandwidth permitting. Thus the default of -1 will try to send the frames at a real-time rate, -2 will be double real-time etc.",
		type => $types{integer},
		category => 'medband',
	},
	{
		name => "ZM_WEB_M_IMAGE_SCALING",
		default => "4",
		description => "How to scale thumbnails in events, bandwidth versus cpu in rescaling",
		help => "A value of 1 sends the whole image to the browser which resizes it in the window, larger values scale down by that amount on the server before sending a reduced size image to the browser. For medium bandwidth settings the default of 4 is usually the fastest though 1 may also work.",
		type => $types{integer},
		requires => [ { name=>"ZM_PATH_NETPBM", value=>"/" } ],
		category => 'medband',
	},
	{
		name => "ZM_WEB_L_REFRESH_MAIN",
		default => "300",
		description => "How often (in seconds) the main console window should refresh itself",
		introduction => "The next few options control what happens when the client is running in 'low' bandwidth mode. You should set these options for when accessing the ZoneMinder client over a modem or slow link. In most cases the default values will be suitable as a starting point.",
		help => "The main console window lists a general status and the event totals for all monitors. This is not a trivial task and should not be repeated too frequently or it may affect the performance of the rest of the system.",
		type => $types{integer},
		category => 'lowband',
	},
	{
		name => "ZM_WEB_L_REFRESH_CYCLE",
		default => "10",
		description => "How often (in seconds) the cycle watch window swaps to the next monitor",
		help => "The cycle watch window is a method of continuously cycling between still images from all of your monitors. This option determines how often to refresh with a new image.",
		type => $types{integer},
		category => 'lowband',
	},
	{
		name => "ZM_WEB_L_REFRESH_IMAGE",
		default => "30",
		description => "How often (in seconds) the watched image is refreshed (if not streaming)",
		help => "The live images from a monitor can be viewed in either streamed or stills mode. This option determines how often a stills image is refreshed, it has no effect if streaming is selected.",
		type => $types{integer},
		category => 'lowband',
	},
	{
		name => "ZM_WEB_L_REFRESH_STATUS",
		default => "10",
		description => "How often (in seconds) the status frame refreshes itself in the watch window",
		help => "The monitor window is actually made from several frames. The one in the middle merely contains a monitor status which needs to refresh fairly frequently to give a true indication. This option determines that frequency.",
		type => $types{integer},
		category => 'lowband',
	},
	{
		name => "ZM_WEB_L_REFRESH_EVENTS",
		default => "180",
		description => "How often (in seconds) the event listing is refreshed in the watch window",
		help => "The monitor window is actually made from several frames. The lower framme contains a listing of the last few events for easy access. This option determines how often this is refreshed.",
		type => $types{integer},
		category => 'lowband',
	},
	{
		name => "ZM_WEB_L_STREAM_IDLE_DELAY",
		default => "10000",
		description => "How long (in milliseconds) between streamed frames in the watch window",
		help => "The top frame of the monitor window when monitoring a live feed in streaming mode contains a continuous stream of images. This option controls how often a new frame is sent to the browser when the monitor is idle, ie. not in alarm state. It makes little sense to set this too small as if it exceeds the available bandwidth and results in frames being sent much faster than they are able to be displayed. In low bandwidth mode it should be set to be far less than the capture rate of the cameras you are using. Note also that this is the update rate when no alarms are being generated, if an alarm situation occurs then the rate speeds up as per the next option so this can be set to a longer delay without you missing anything.",
		type => $types{integer},
		category => 'lowband',
	},
	{
		name => "ZM_WEB_L_STREAM_FRAME_DELAY",
		default => "250",
		description => "How long (in milliseconds) to wait before looking for the next streamed frame",
		help => "The top frame of the monitor window when monitoring a live feed in streaming mode contains a continuous stream of images. This option controls how often a new frame is sent to the browser when an alarm is being generated. It makes little sense to set this too small as if it exceeds the available bandwidth and results in frames being sent much faster than they are able to be displayed though as should be only for a short period it may be possible to catch up. In low bandwidth mode it should be set to maybe a quarter the capture rate of the cameras you are using.",
		type => $types{integer},
		category => 'lowband',
	},
	{
		name => "ZM_WEB_L_STREAM_EVENT_DELAY",
		default => "-1",
		description => "How long to wait between each frame when streaming events",
		help => "When viewing a captured event this option controls how fast frames are sent to the browser. If this is a positive value then this represents the interval in milliseconds between each frame and should roughly match your capture rate otherwise the event may appear too fast or too slow. If zero then frames are sent as fast as possible. If this value is negative then the frames are sent at a rate proportional to the real interval at which they were captured, bandwidth permitting. Thus the default of -1 will try to send the frames at a real-time rate, -2 will be double real-time etc.",
		type => $types{integer},
		category => 'lowband',
	},
	{
		name => "ZM_WEB_L_IMAGE_SCALING",
		default => "4",
		description => "How to scale thumbnails in events, bandwidth versus cpu in rescaling",
		help => "A value of 1 sends the whole image to the browser which resizes it in the window, larger values scale down by that amount on the server before sending a reduced size image to the browser. For low bandwidth settings the default of 4 is usually the best.",
		type => $types{integer},
		requires => [ { name=>"ZM_PATH_NETPBM", value=>"/" } ],
		category => 'lowband',
	},
	{
		name => "ZM_WEB_P_REFRESH_MAIN",
		default => "300",
		description => "How often (in seconds) the main console window should refresh itself",
		introduction => "The next few options control what happens when the WAP client is being accessed over a mobile phone link. You should set these options for when accessing the ZoneMinder WAP client over a mobile dialup or GPRS link. In most cases the default values will be suitable as a starting point.",
		help => "The main console window lists a general status and the event totals for all monitors. This is not a trivial task and should not be repeated too frequently or it may affect the performance of the rest of the system.",
		type => $types{integer},
		category => 'phoneband',
	},
	{
		name => "ZM_WEB_P_REFRESH_IMAGE",
		default => "30",
		description => "How often (in seconds) the watched image is refreshed",
		help => "The live images from a monitor are viewed as a sequence of still images. This option determines how the image is refreshed. Though the images are small setting this at too frequent a value may rapidly consume a lot of bandwidth resource.",
		type => $types{integer},
		category => 'phoneband',
	},
);

#my %option_id;
#map { $option_id{$_->{category}} = (256 * int(keys(%option_id))) if ( !$option_id{$_->{category}} ); $_->{id} = ++$option_id{$_->{category}} } @options;
my %options_hash = map { ( $_->{name}, $_ ) } @options;

#$config_file = "zmconfig.txt" if ( !$config_file );

foreach my $option ( @options )
{
	if ( $option->{default} )
	{
		$option->{value} = $option->{default}
	}
	else
	{
		$option->{value} = '';
	}
}

my $file_option_count = 0;
if ( -s $config_file )
{
	$file_option_count = loadOptionsFromFile();
}
my $db_option_count = loadOptionsFromDB();
if ( !$interactive && !$file_option_count && !$db_option_count )
{
	print( "Warning: Non-interative mode being used with no existing configuration information.\n" );
	print( "         Using only default values which may not be appropriate or even work.\n" );
}

if ( $interactive )
{
	print( "
Welcome to the ZoneMinder interactive configuration utility.

You will now be prompted to enter information allowing ZoneMinder to
be configured for your system. Entering '?' at most prompts will print
further information about each option if you are not sure what to put.
You can also type 'q' at any time to exit without saving or 'x' to 
exit with the remaining options set to their previous or default 
values.

Press enter to continue: " );
	my $input = <>;
	print( "\n" );

	foreach my $option ( @options )
	{
		next if ( $option->{readonly} );
		next if ( @match_options && !grep { $option->{name} =~ /^$_$/ } @match_options );
	
		if ( my $requires = $option->{requires} )
		{
			my $do_option;
			foreach my $require ( @$requires )
			{
				if ( my $require_option = $options_hash{$require->{name}} )
				{
					if ( $require_option->{value} =~ /^$require->{value}/ )
					{
						$do_option = !undef;
						last;
					}
				}
			}
			next if ( !$do_option );
		}
		if ( $option->{introduction} )
		{
			print( '-'x76 . "\n" );
			print( breaktext( $option->{introduction} ) );
			print( '-'x76 . "\n" );
		}
		my $type = $option->{type};
		if ( !$type )
		{
			warn( "No type found" );
			$type = $types{string};
		}
		while( 1 )
		{
			print( "$option->{description} ($type->{hint}) " );
			print( "[$option->{value}] " ) if ( defined($option->{value}) );
			print( ": " );
			my $new_value = <>;
			chomp( $new_value );
			if ( defined($new_value) )
			{
				if ( $new_value =~ /^\?/ )
				{
					if ( $option->{help} )
					{
						print( "\n".breaktext($option->{help})."\n" );
					}
					else
					{
						print( "Sorry, no help is available for this item\n" );
					}
					next;
				}
				elsif ( $new_value eq 'x' )
				{
					print( "Using existing values for remaining options\n" );
					goto FINISHED;
				}
				elsif ( $new_value eq 'q' )
				{
					print( "Exiting\n" );
					exit( 0 );
				}
				elsif ( $new_value eq '' )
				{
					if ( $option->{value} )
					{
						last;
					}
				}
				#print( "N:$new_value\n" );
				my $pattern = $type->{pattern};
				if ( $new_value !~ $pattern || ( $type->{check} && !eval( $type->{check} ) ) )
				{
					print( "Invalid input, please re-enter or type '?' for help.\n" );
					next;
				}
				#print( "U:$use_value\n" );
				my $format = $type->{format};
				$option->{value} = eval( $format );
			}
			last;
		}
		if ( my $check = $option->{check} )
		{
			if ( my $result = &$check( $option->{value} ) )
			{
				# All ok
				print( "Exists\n" );
			}
			else
			{
				print( "Missing\n" );
			}
		}
	}
}
FINISHED:
saveOptionsToFile();
saveOptionsToDB();

sub saveOptionsToFile
{
	print( "Saving config to '$config_file'\n" );
	open( CONFIG, ">$config_file" ) or die( "Can't open options file: $!" );
	foreach my $option ( @options )
	{
		next if ( $option->{readonly} );
		next if ( $option->{type} == $types{text} );
		print( CONFIG "Name: $option->{name}\n" );
		print( CONFIG "Value: $option->{value}\n" );
		print( CONFIG "Description: $option->{description}\n" );
		print( CONFIG "\n" );
	}
	close( CONFIG );
}

sub saveOptionsToDB
{
	print( "Saving config to DB\n" );
	my $dbh = DBI->connect( "DBI:mysql:database=".$options_hash{ZM_DB_NAME}->{value}.";host=".$options_hash{ZM_DB_SERVER}->{value}, $options_hash{ZM_DB_USERA}->{value}, $options_hash{ZM_DB_PASSA}->{value} ) or die( "Can't connect: ".$DBI::errstr );

	my $sql = "delete from Config";
	my $res = $dbh->do( $sql ) or die( "Can't do '$sql': ".$dbh->errstr() );

	$sql = "replace into Config set Id = ?, Name = ?, Value = ?, Type = ?, DefaultValue = ?, Hint = ?, Pattern = ?, Format = ?, Prompt = ?, Help = ?, Category = ?, Readonly = ?, Requires = ?";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $option_id = 0;
	foreach my $option ( @options )
	{
		next if ( $option->{category} eq 'core' );
		next if ( $option->{type} == $types{include} );
		#print( $option->{name}."\n" ) if ( !$option->{category} );
		$option->{db_type} = $option->{type}->{db_type};
		$option->{db_hint} = $option->{type}->{hint};
		$option->{db_pattern} = $option->{type}->{pattern};
		$option->{db_format} = $option->{type}->{format};
		if ( $option->{db_type} eq "boolean" )
		{
			$option->{db_value} = ($option->{value} eq "yes")?"1":"0";
		}
		else
		{
			$option->{db_value} = $option->{value};
		}
		if ( my $requires = $option->{requires} )
		{
			$option->{db_requires} = join( ";", map { my $value = $_->{value}; $value = ($value eq "yes")?1:0 if ( $options_hash{$_->{name}}->{db_type} eq "boolean" ); ( "$_->{name}=$value" ) } @$requires );
		}
		else
		{
		}
		$option->{id} = $option_id++;
		my $res = $sth->execute( $option->{id}, $option->{name}, $option->{db_value}, $option->{db_type}, $option->{default}, $option->{db_hint}, $option->{db_pattern}, $option->{db_format}, $option->{description}, $option->{help}, $option->{category}, $option->{readonly}?1:0, $option->{db_requires} ) or die( "Can't execute: ".$sth->errstr() );
	}
	$sth->finish();
	$dbh->disconnect();
}

sub loadOptionsFromFile
{
	print( "Loading config from '$config_file'\n" );
	open( CONFIG, "<$config_file" ) or die( "Can't open options file: $!" );
	local $/ = "\n\n";
	my $option_count = 0;
	foreach my $section ( <CONFIG> )
	{
		my ( $name, $value, $description ) = $section =~ /Name: (.*)\nValue: (.*)\nDescription: (.*)\n/ms;
		#print( "Name = '$name'\n" );
		my $option = $options_hash{$name};
		if ( !$option )
		{
			warn( "No option '$name' found, removing" );
			next;
		}
		if ( defined($value) )
		{
			if ( $name eq "ZM_OPT_MPEG" && $value eq "yes" )
			{
				$value = "mpeg_encode";
			}
			$option->{value} = $value;
		}
		$option_count++;;
	}
	close( CONFIG );
	foreach my $option ( @options )
	{
		if ( $option->{type} == $types{include} )
		{
			open( FILE, $option->{value} ) or die( "Can't open option file '$option->{value}': $!" );
			local $/;
			my $content = <FILE>;
			close( FILE );
			( my $text_option_name = $option->{name} ) =~ s/FORMAT/TEXT/;
			my $text_option = $options_hash{$text_option_name};
			die( "Can't find $text_option_name option for include" ) unless( $text_option );
			$text_option->{value} = $content;
		}
	}
	return( $option_count );
}

sub loadOptionsFromDB
{
	print( "Loading config from DB\n" );
	my $dbh = DBI->connect( "DBI:mysql:database=".$options_hash{ZM_DB_NAME}->{value}.";host=".$options_hash{ZM_DB_SERVER}->{value}, $options_hash{ZM_DB_USERA}->{value}, $options_hash{ZM_DB_PASSA}->{value} ) or die( "Can't connect: ".$DBI::errstr );
	my $sql = "select * from Config";
	my $sth = $dbh->prepare_cached( $sql ) or die( "Can't prepare '$sql': ".$dbh->errstr() );
	my $res = $sth->execute() or die( "Can't execute: ".$sth->errstr() );
	my $option_count = 0;
	while( my $config = $sth->fetchrow_hashref() )
	{
		my ( $name, $value ) = ( $config->{Name}, $config->{Value} );
		#print( "Name = '$name'\n" );
		my $option = $options_hash{$name};
		if ( !$option )
		{
			warn( "No option '$name' found, removing" );
			next;
		}
		next if ( $option->{category} eq 'core' );
		if ( defined($value) )
		{
			if ( $name eq "ZM_OPT_MPEG" && $value eq "yes" )
			{
				$value = "mpeg_encode";
			}
			if ( $option->{type} == $types{boolean} )
			{
				$option->{value} = $value?"yes":"no";
			}
			else
			{
				$option->{value} = $value;
			}
		}
		$option_count++;;
	}
	close( CONFIG );
	$dbh->disconnect();
	return( $option_count );
}

sub breaktext
{
	my $text = shift;
	( my $broken_text = $text ) =~ s/(.{1,76})(?:\s|$)/$1\n/g;
	return( $broken_text );
}

if ( $reprocess )
{
	print( "Generating '$config_header'\n" );
	open( CFG_HDR_FILE, ">$config_header" ) or die( "Can't open '$config_header' for writing" );
	print( CFG_HDR_FILE "// The file is autogenerated by zmconfig.pl\n" );
	print( CFG_HDR_FILE "// Do not edit this file as any changes will be overwritten\n\n" );
	my $last_id = 0;
	foreach my $option ( @options )
	{
		#next if ( $option->{category} eq 'core' );
		next if ( !defined($option->{id}) );
		#printf( CFG_HDR_FILE "#define $option->{name} 0x%04X\n", $option->{id} );
		printf( CFG_HDR_FILE "#define $option->{name} $option->{id}\n" );
		$last_id = $option->{id};
	}
	printf( CFG_HDR_FILE "#define ZM_MAX_CFG_ID $last_id\n" );
	close( CFG_HDR_FILE );

	my @config_files = qw( src/zm_config.h web/zm_config.php scripts/zmdc.pl scripts/zmwatch.pl scripts/zmaudit.pl scripts/zmfilter.pl scripts/zmx10.pl scripts/zmpkg.pl scripts/zmvideo.pl scripts/zm db/zmschema.sql );

	foreach my $config_file ( @config_files )
	{
		print( "Processing '$config_file'\n" );
		local $/ = undef;
		my $config_z_file = $config_file.".z";
		open( CFG_IN_FILE, $config_z_file ) or die( "Can't open '$config_z_file' for reading" );
		my $data = <CFG_IN_FILE>;
		close( CFG_IN_FILE );
		if ( $config_file =~ /\.h$/ )
		{
			foreach my $option ( @options )
			{
				my $opt_name = $option->{name};
				my $opt_type = $option->{type};
				my $opt_value = $option->{value};
				my $opt_desc = $option->{description};
				if ( $opt_type == $types{boolean} )
				{
					$opt_value = "true" if ( $opt_value eq "yes" );
					$opt_value = "false" if ( $opt_value eq "no" );
				}
				if ( $opt_type == $types{boolean}
				|| $opt_type == $types{integer}
				|| $opt_type == $types{decimal}
				|| $opt_type == $types{hexadecimal} )
				{
					$data =~ s/^(#define\s+$opt_name\s+).*$/$1$opt_value\t\/\/ $opt_desc \(from zmconfig\)/mg;
				}
				else
				{
					$data =~ s/^(#define\s+$opt_name\s+).*$/$1"$opt_value"\t\/\/ $opt_desc \(from zmconfig\)/mg;
				}
			}
		}
		elsif ( $config_file =~ /\.pl$/ )
		{
			foreach my $option ( @options )
			{
				my $opt_name = $option->{name};
				my $opt_type = $option->{type};
				my $opt_value = $option->{value};
				my $opt_desc = $option->{description};
				if ( $opt_type == $types{boolean} )
				{
					$opt_value = 1 if ( $opt_value eq "yes" );
					$opt_value = 0 if ( $opt_value eq "no" );
				}
				if ( $opt_type == $types{boolean}
				|| $opt_type == $types{integer}
				|| $opt_type == $types{decimal}
				|| $opt_type == $types{hexadecimal} )
				{
					$data =~ s/^(\s*use\s+constant\s+$opt_name\s*=>\s*).*$/$1$opt_value;\t# $opt_desc \(from zmconfig\)/mg;
				}
				elsif ( $opt_type == $types{email} )
				{
					$opt_value =~ s/\@/\\\@/;
					$data =~ s/^(\s*use\s+constant\s+$opt_name\s*=>\s*).*$/$1"$opt_value";\t# $opt_desc \(from zmconfig\)/mg;
				}
				elsif ( $opt_type == $types{include} )
				{
					open( FILE, "<$opt_value" ) or die( "Can't open option file '$opt_value': $!" );
					local $/;
					my $content = <FILE>;
					$content =~ s/"/\\"/g;
					$data =~ s/^(\s*use\s+constant\s+$opt_name\s*=>\s*).*$/$1\t# $opt_desc \(from zmconfig\)\n"$content";/mg;
				}
				else
				{
					$data =~ s/^(\s*use\s+constant\s+$opt_name\s*=>\s*).*$/$1"$opt_value";\t# $opt_desc \(from zmconfig\)/mg;
				}
			}
		}
		elsif ( $config_file =~ /\.php$/ )
		{
			foreach my $option ( @options )
			{
				my $opt_name = $option->{name};
				my $opt_type = $option->{type};
				my $opt_value = $option->{value};
				my $opt_desc = $option->{description};
				if ( $opt_type == $types{boolean} )
				{
					$opt_value = "true" if ( $opt_value eq "yes" );
					$opt_value = "false" if ( $opt_value eq "no" );
				}
				if ( $opt_type == $types{boolean}
				|| $opt_type == $types{integer}
				|| $opt_type == $types{decimal}
				|| $opt_type == $types{hexadecimal} )
				{
					$data =~ s/^(define\s*\(\s*"$opt_name"\s*,\s*).*$/$1$opt_value \);\t\/\/ $opt_desc \(from zmconfig\)/mg;
				}
				else
				{
					$data =~ s/^(define\s*\(\s*"$opt_name"\s*,\s*).*$/$1"$opt_value" \);\t\/\/ $opt_desc \(from zmconfig\)/mg;
				}
			}
		}
		elsif ( $config_file =~ /\.sql$/ )
		{
			foreach my $option ( @options )
			{
				my $opt_name = $option->{name};
				my $opt_type = $option->{type};
				my $opt_value = $option->{value};
				my $opt_desc = $option->{description};
				$data =~ s/$opt_name/$opt_value/mg;
			}
		}
		elsif ( $config_file !~ /\./ )
		{
			foreach my $option ( @options )
			{
				my $opt_name = $option->{name};
				my $opt_type = $option->{type};
				my $opt_value = $option->{value};
				my $opt_desc = $option->{description};
				$data =~ s/^$opt_name\s*=.*$/$opt_name="$opt_value"/mg;
			}
		}
		else
		{
			warn( "Unrecognised file type '$config_file'" );
			next;
		}
		open( CFG_FILE, ">$config_file" ) or die( "Can't open '$config_file' for writing" );
		print( CFG_FILE $data );
		close( CFG_FILE );
	}
}
